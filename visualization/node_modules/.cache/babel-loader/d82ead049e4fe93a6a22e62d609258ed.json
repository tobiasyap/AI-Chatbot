{"ast":null,"code":"import { nelderMead, bisect, norm2, zeros, conjugateGradient, scale, zerosM } from 'fmin';\nconst SMALL = 1e-10;\n/**\n * Returns the intersection area of a bunch of circles (where each circle\n * is an object having an x,y and radius property)\n * @param {ReadonlyArray<{x: number, y: number, radius: number}>} circles\n * @param {undefined | { area?: number, arcArea?: number, polygonArea?: number, arcs?: ReadonlyArray<{ circle: {x: number, y: number, radius: number}, width: number, p1: {x: number, y: number}, p2: {x: number, y: number} }>, innerPoints: ReadonlyArray<{\n    x: number;\n    y: number;\n    parentIndex: [number, number];\n}>, intersectionPoints: ReadonlyArray<{\n  x: number;\n  y: number;\n  parentIndex: [number, number];\n}> }} stats\n * @returns {number}\n */\n\nfunction intersectionArea(circles, stats) {\n  // get all the intersection points of the circles\n  const intersectionPoints = getIntersectionPoints(circles); // filter out points that aren't included in all the circles\n\n  const innerPoints = intersectionPoints.filter(p => containedInCircles(p, circles));\n  let arcArea = 0;\n  let polygonArea = 0;\n  /** @type {{ circle: {x: number, y: number, radius: number}, width: number, p1: {x: number, y: number}, p2: {x: number, y: number} }[]} */\n\n  const arcs = []; // if we have intersection points that are within all the circles,\n  // then figure out the area contained by them\n\n  if (innerPoints.length > 1) {\n    // sort the points by angle from the center of the polygon, which lets\n    // us just iterate over points to get the edges\n    const center = getCenter(innerPoints);\n\n    for (let i = 0; i < innerPoints.length; ++i) {\n      const p = innerPoints[i];\n      p.angle = Math.atan2(p.x - center.x, p.y - center.y);\n    }\n\n    innerPoints.sort((a, b) => b.angle - a.angle); // iterate over all points, get arc between the points\n    // and update the areas\n\n    let p2 = innerPoints[innerPoints.length - 1];\n\n    for (let i = 0; i < innerPoints.length; ++i) {\n      const p1 = innerPoints[i]; // polygon area updates easily ...\n\n      polygonArea += (p2.x + p1.x) * (p1.y - p2.y); // updating the arc area is a little more involved\n\n      const midPoint = {\n        x: (p1.x + p2.x) / 2,\n        y: (p1.y + p2.y) / 2\n      };\n      /** @types null | { circle: {x: number, y: number, radius: number}, width: number, p1: {x: number, y: number}, p2: {x: number, y: number} } */\n\n      let arc = null;\n\n      for (let j = 0; j < p1.parentIndex.length; ++j) {\n        if (p2.parentIndex.includes(p1.parentIndex[j])) {\n          // figure out the angle halfway between the two points\n          // on the current circle\n          const circle = circles[p1.parentIndex[j]];\n          const a1 = Math.atan2(p1.x - circle.x, p1.y - circle.y);\n          const a2 = Math.atan2(p2.x - circle.x, p2.y - circle.y);\n          let angleDiff = a2 - a1;\n\n          if (angleDiff < 0) {\n            angleDiff += 2 * Math.PI;\n          } // and use that angle to figure out the width of the\n          // arc\n\n\n          const a = a2 - angleDiff / 2;\n          let width = distance(midPoint, {\n            x: circle.x + circle.radius * Math.sin(a),\n            y: circle.y + circle.radius * Math.cos(a)\n          }); // clamp the width to the largest is can actually be\n          // (sometimes slightly overflows because of FP errors)\n\n          if (width > circle.radius * 2) {\n            width = circle.radius * 2;\n          } // pick the circle whose arc has the smallest width\n\n\n          if (arc == null || arc.width > width) {\n            arc = {\n              circle,\n              width,\n              p1,\n              p2,\n              large: width > circle.radius,\n              sweep: true\n            };\n          }\n        }\n      }\n\n      if (arc != null) {\n        arcs.push(arc);\n        arcArea += circleArea(arc.circle.radius, arc.width);\n        p2 = p1;\n      }\n    }\n  } else {\n    // no intersection points, is either disjoint - or is completely\n    // overlapped. figure out which by examining the smallest circle\n    let smallest = circles[0];\n\n    for (let i = 1; i < circles.length; ++i) {\n      if (circles[i].radius < smallest.radius) {\n        smallest = circles[i];\n      }\n    } // make sure the smallest circle is completely contained in all\n    // the other circles\n\n\n    let disjoint = false;\n\n    for (let i = 0; i < circles.length; ++i) {\n      if (distance(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {\n        disjoint = true;\n        break;\n      }\n    }\n\n    if (disjoint) {\n      arcArea = polygonArea = 0;\n    } else {\n      arcArea = smallest.radius * smallest.radius * Math.PI;\n      arcs.push({\n        circle: smallest,\n        p1: {\n          x: smallest.x,\n          y: smallest.y + smallest.radius\n        },\n        p2: {\n          x: smallest.x - SMALL,\n          y: smallest.y + smallest.radius\n        },\n        width: smallest.radius * 2,\n        large: true,\n        sweep: true\n      });\n    }\n  }\n\n  polygonArea /= 2;\n\n  if (stats) {\n    stats.area = arcArea + polygonArea;\n    stats.arcArea = arcArea;\n    stats.polygonArea = polygonArea;\n    stats.arcs = arcs;\n    stats.innerPoints = innerPoints;\n    stats.intersectionPoints = intersectionPoints;\n  }\n\n  return arcArea + polygonArea;\n}\n/**\n * returns whether a point is contained by all of a list of circles\n * @param {{x: number, y: number}} point\n * @param {ReadonlyArray<{x: number, y: number, radius: number}>} circles\n * @returns {boolean}\n */\n\n\nfunction containedInCircles(point, circles) {\n  return circles.every(circle => distance(point, circle) < circle.radius + SMALL);\n}\n/**\n * Gets all intersection points between a bunch of circles\n * @param {ReadonlyArray<{x: number, y: number, radius: number}>} circles\n * @returns {ReadonlyArray<{x: number, y: number, parentIndex: [number, number]}>}\n */\n\n\nfunction getIntersectionPoints(circles) {\n  /** @type {{x: number, y: number, parentIndex: [number, number]}[]} */\n  const ret = [];\n\n  for (let i = 0; i < circles.length; ++i) {\n    for (let j = i + 1; j < circles.length; ++j) {\n      const intersect = circleCircleIntersection(circles[i], circles[j]);\n\n      for (const p of intersect) {\n        p.parentIndex = [i, j];\n        ret.push(p);\n      }\n    }\n  }\n\n  return ret;\n}\n/**\n * Circular segment area calculation. See http://mathworld.wolfram.com/CircularSegment.html\n * @param {number} r\n * @param {number} width\n * @returns {number}\n **/\n\n\nfunction circleArea(r, width) {\n  return r * r * Math.acos(1 - width / r) - (r - width) * Math.sqrt(width * (2 * r - width));\n}\n/**\n * euclidean distance between two points\n * @param {{x: number, y: number}} p1\n * @param {{x: number, y: number}} p2\n * @returns {number}\n **/\n\n\nfunction distance(p1, p2) {\n  return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n}\n/**\n * Returns the overlap area of two circles of radius r1 and r2 - that\n * have their centers separated by distance d. Simpler faster\n * circle intersection for only two circles\n * @param {number} r1\n * @param {number} r2\n * @param {number} d\n * @returns {number}\n */\n\n\nfunction circleOverlap(r1, r2, d) {\n  // no overlap\n  if (d >= r1 + r2) {\n    return 0;\n  } // completely overlapped\n\n\n  if (d <= Math.abs(r1 - r2)) {\n    return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);\n  }\n\n  const w1 = r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d);\n  const w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d);\n  return circleArea(r1, w1) + circleArea(r2, w2);\n}\n/**\n * Given two circles (containing a x/y/radius attributes),\n * returns the intersecting points if possible\n * note: doesn't handle cases where there are infinitely many\n * intersection points (circles are equivalent):, or only one intersection point\n * @param {{x: number, y: number, radius: number}} p1\n * @param {{x: number, y: number, radius: number}} p2\n * @returns {ReadonlyArray<{x: number, y: number}>}\n **/\n\n\nfunction circleCircleIntersection(p1, p2) {\n  const d = distance(p1, p2);\n  const r1 = p1.radius;\n  const r2 = p2.radius; // if to far away, or self contained - can't be done\n\n  if (d >= r1 + r2 || d <= Math.abs(r1 - r2)) {\n    return [];\n  }\n\n  const a = (r1 * r1 - r2 * r2 + d * d) / (2 * d);\n  const h = Math.sqrt(r1 * r1 - a * a);\n  const x0 = p1.x + a * (p2.x - p1.x) / d;\n  const y0 = p1.y + a * (p2.y - p1.y) / d;\n  const rx = -(p2.y - p1.y) * (h / d);\n  const ry = -(p2.x - p1.x) * (h / d);\n  return [{\n    x: x0 + rx,\n    y: y0 - ry\n  }, {\n    x: x0 - rx,\n    y: y0 + ry\n  }];\n}\n/**\n * Returns the center of a bunch of points\n * @param {ReadonlyArray<{x: number, y: number}>} points\n * @returns {{x: number, y: number}}\n */\n\n\nfunction getCenter(points) {\n  const center = {\n    x: 0,\n    y: 0\n  };\n\n  for (const point of points) {\n    center.x += point.x;\n    center.y += point.y;\n  }\n\n  center.x /= points.length;\n  center.y /= points.length;\n  return center;\n}\n/**\n * given a list of set objects, and their corresponding overlaps\n * updates the (x, y, radius) attribute on each set such that their positions\n * roughly correspond to the desired overlaps\n * @param {readonly {sets: readonly string[]; size: number; weight?: number}[]} sets\n * @returns {{[setid: string]: {x: number, y: number, radius: number}}}\n */\n\n\nfunction venn(sets) {\n  let parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  parameters.maxIterations = parameters.maxIterations || 500;\n  const initialLayout = parameters.initialLayout || bestInitialLayout;\n  const loss = parameters.lossFunction || lossFunction; // add in missing pairwise areas as having 0 size\n\n  const areas = addMissingAreas(sets, parameters); // initial layout is done greedily\n\n  const circles = initialLayout(areas, parameters); // transform x/y coordinates to a vector to optimize\n\n  const setids = Object.keys(circles);\n  /** @type {number[]} */\n\n  const initial = [];\n\n  for (const setid of setids) {\n    initial.push(circles[setid].x);\n    initial.push(circles[setid].y);\n  } // optimize initial layout from our loss function\n\n\n  const solution = nelderMead(values => {\n    const current = {};\n\n    for (let i = 0; i < setids.length; ++i) {\n      const setid = setids[i];\n      current[setid] = {\n        x: values[2 * i],\n        y: values[2 * i + 1],\n        radius: circles[setid].radius // size : circles[setid].size\n\n      };\n    }\n\n    return loss(current, areas);\n  }, initial, parameters); // transform solution vector back to x/y points\n\n  const positions = solution.x;\n\n  for (let i = 0; i < setids.length; ++i) {\n    const setid = setids[i];\n    circles[setid].x = positions[2 * i];\n    circles[setid].y = positions[2 * i + 1];\n  }\n\n  return circles;\n}\n\nconst SMALL$1 = 1e-10;\n/**\n * Returns the distance necessary for two circles of radius r1 + r2 to\n * have the overlap area 'overlap'\n * @param {number} r1\n * @param {number} r2\n * @param {number} overlap\n * @returns {number}\n */\n\nfunction distanceFromIntersectArea(r1, r2, overlap) {\n  // handle complete overlapped circles\n  if (Math.min(r1, r2) * Math.min(r1, r2) * Math.PI <= overlap + SMALL$1) {\n    return Math.abs(r1 - r2);\n  }\n\n  return bisect(distance => circleOverlap(r1, r2, distance) - overlap, 0, r1 + r2);\n}\n/**\n * Missing pair-wise intersection area data can cause problems:\n * treating as an unknown means that sets will be laid out overlapping,\n * which isn't what people expect. To reflect that we want disjoint sets\n * here, set the overlap to 0 for all missing pairwise set intersections\n * @param {ReadonlyArray<{sets: ReadonlyArray<string>, size: number}>} areas\n * @returns {ReadonlyArray<{sets: ReadonlyArray<string>, size: number}>}\n */\n\n\nfunction addMissingAreas(areas) {\n  let parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const distinct = parameters.distinct;\n  const r = areas.map(s => Object.assign({}, s));\n\n  function toKey(arr) {\n    return arr.join(';');\n  }\n\n  if (distinct) {\n    // recreate the full ones by adding things up but just to level two since the rest doesn't matter\n\n    /** @types Map<string, number> */\n    const count = new Map();\n\n    for (const area of r) {\n      for (let i = 0; i < area.sets.length; i++) {\n        const si = String(area.sets[i]);\n        count.set(si, area.size + (count.get(si) || 0));\n\n        for (let j = i + 1; j < area.sets.length; j++) {\n          const sj = String(area.sets[j]);\n          const k1 = `${si};${sj}`;\n          const k2 = `${sj};${si}`;\n          count.set(k1, area.size + (count.get(k1) || 0));\n          count.set(k2, area.size + (count.get(k2) || 0));\n        }\n      }\n    }\n\n    for (const area of r) {\n      if (area.sets.length < 3) {\n        area.size = count.get(toKey(area.sets));\n      }\n    }\n  } // two circle intersections that aren't defined\n\n\n  const ids = [];\n  /** @type {Set<string>} */\n\n  const pairs = new Set();\n\n  for (const area of r) {\n    if (area.sets.length === 1) {\n      ids.push(area.sets[0]);\n    } else if (area.sets.length === 2) {\n      const a = area.sets[0];\n      const b = area.sets[1];\n      pairs.add(toKey(area.sets));\n      pairs.add(toKey([b, a]));\n    }\n  }\n\n  ids.sort((a, b) => a === b ? 0 : a < b ? -1 : +1);\n\n  for (let i = 0; i < ids.length; ++i) {\n    const a = ids[i];\n\n    for (let j = i + 1; j < ids.length; ++j) {\n      const b = ids[j];\n\n      if (!pairs.has(toKey([a, b]))) {\n        r.push({\n          sets: [a, b],\n          size: 0\n        });\n      }\n    }\n  }\n\n  return r;\n}\n/**\n * Returns two matrices, one of the euclidean distances between the sets\n * and the other indicating if there are subset or disjoint set relationships\n * @param {ReadonlyArray<{sets: ReadonlyArray<number>}>} areas\n * @param {ReadonlyArray<{size: number}>} sets\n * @param {ReadonlyArray<number>} setids\n */\n\n\nfunction getDistanceMatrices(areas, sets, setids) {\n  // initialize an empty distance matrix between all the points\n\n  /**\n   * @type {number[][]}\n   */\n  const distances = zerosM(sets.length, sets.length);\n  /**\n   * @type {number[][]}\n   */\n\n  const constraints = zerosM(sets.length, sets.length); // compute required distances between all the sets such that\n  // the areas match\n\n  areas.filter(x => x.sets.length === 2).forEach(current => {\n    const left = setids[current.sets[0]];\n    const right = setids[current.sets[1]];\n    const r1 = Math.sqrt(sets[left].size / Math.PI);\n    const r2 = Math.sqrt(sets[right].size / Math.PI);\n    const distance = distanceFromIntersectArea(r1, r2, current.size);\n    distances[left][right] = distances[right][left] = distance; // also update constraints to indicate if its a subset or disjoint\n    // relationship\n\n    let c = 0;\n\n    if (current.size + 1e-10 >= Math.min(sets[left].size, sets[right].size)) {\n      c = 1;\n    } else if (current.size <= 1e-10) {\n      c = -1;\n    }\n\n    constraints[left][right] = constraints[right][left] = c;\n  });\n  return {\n    distances,\n    constraints\n  };\n} /// computes the gradient and loss simultaneously for our constrained MDS optimizer\n\n\nfunction constrainedMDSGradient(x, fxprime, distances, constraints) {\n  for (let i = 0; i < fxprime.length; ++i) {\n    fxprime[i] = 0;\n  }\n\n  let loss = 0;\n\n  for (let i = 0; i < distances.length; ++i) {\n    const xi = x[2 * i];\n    const yi = x[2 * i + 1];\n\n    for (let j = i + 1; j < distances.length; ++j) {\n      const xj = x[2 * j];\n      const yj = x[2 * j + 1];\n      const dij = distances[i][j];\n      const constraint = constraints[i][j];\n      const squaredDistance = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi);\n      const distance = Math.sqrt(squaredDistance);\n      const delta = squaredDistance - dij * dij;\n\n      if (constraint > 0 && distance <= dij || constraint < 0 && distance >= dij) {\n        continue;\n      }\n\n      loss += 2 * delta * delta;\n      fxprime[2 * i] += 4 * delta * (xi - xj);\n      fxprime[2 * i + 1] += 4 * delta * (yi - yj);\n      fxprime[2 * j] += 4 * delta * (xj - xi);\n      fxprime[2 * j + 1] += 4 * delta * (yj - yi);\n    }\n  }\n\n  return loss;\n}\n/**\n * takes the best working variant of either constrained MDS or greedy\n * @param {ReadonlyArray<{sets: ReadonlyArray<string>, size: number}>} areas\n */\n\n\nfunction bestInitialLayout(areas) {\n  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let initial = greedyLayout(areas, params);\n  const loss = params.lossFunction || lossFunction; // greedylayout is sufficient for all 2/3 circle cases. try out\n  // constrained MDS for higher order problems, take its output\n  // if it outperforms. (greedy is aesthetically better on 2/3 circles\n  // since it axis aligns)\n\n  if (areas.length >= 8) {\n    const constrained = constrainedMDSLayout(areas, params);\n    const constrainedLoss = loss(constrained, areas);\n    const greedyLoss = loss(initial, areas);\n\n    if (constrainedLoss + 1e-8 < greedyLoss) {\n      initial = constrained;\n    }\n  }\n\n  return initial;\n}\n/**\n * use the constrained MDS variant to generate an initial layout\n * @param {ReadonlyArray<{sets: ReadonlyArray<string>, size: number}>} areas\n * @returns {{[key: string]: {x: number, y: number, radius: number}}}\n */\n\n\nfunction constrainedMDSLayout(areas) {\n  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const restarts = params.restarts || 10; // bidirectionally map sets to a rowid  (so we can create a matrix)\n\n  const sets = [];\n  const setids = {};\n\n  for (const area of areas) {\n    if (area.sets.length === 1) {\n      setids[area.sets[0]] = sets.length;\n      sets.push(area);\n    }\n  }\n\n  let {\n    distances,\n    constraints\n  } = getDistanceMatrices(areas, sets, setids); // keep distances bounded, things get messed up otherwise.\n  // TODO: proper preconditioner?\n\n  const norm = norm2(distances.map(norm2)) / distances.length;\n  distances = distances.map(row => row.map(value => value / norm));\n\n  const obj = (x, fxprime) => constrainedMDSGradient(x, fxprime, distances, constraints);\n\n  let best = null;\n\n  for (let i = 0; i < restarts; ++i) {\n    const initial = zeros(distances.length * 2).map(Math.random);\n    const current = conjugateGradient(obj, initial, params);\n\n    if (!best || current.fx < best.fx) {\n      best = current;\n    }\n  }\n\n  const positions = best.x; // translate rows back to (x,y,radius) coordinates\n\n  /** @type {{[key: string]: {x: number, y: number, radius: number}}} */\n\n  const circles = {};\n\n  for (let i = 0; i < sets.length; ++i) {\n    const set = sets[i];\n    circles[set.sets[0]] = {\n      x: positions[2 * i] * norm,\n      y: positions[2 * i + 1] * norm,\n      radius: Math.sqrt(set.size / Math.PI)\n    };\n  }\n\n  if (params.history) {\n    for (const h of params.history) {\n      scale(h.x, norm);\n    }\n  }\n\n  return circles;\n}\n/**\n * Lays out a Venn diagram greedily, going from most overlapped sets to\n * least overlapped, attempting to position each new set such that the\n * overlapping areas to already positioned sets are basically right\n * @param {ReadonlyArray<{size: number, sets: ReadonlyArray<string>}>} areas\n * @return {{[key: string]: {x: number, y: number, radius: number}}}\n */\n\n\nfunction greedyLayout(areas, params) {\n  const loss = params && params.lossFunction ? params.lossFunction : lossFunction; // define a circle for each set\n\n  /** @type {{[key: string]: {x: number, y: number, radius: number}}} */\n\n  const circles = {};\n  /** @type {{[key: string]: {set: string, size: number, weight: number}[]}} */\n\n  const setOverlaps = {};\n\n  for (const area of areas) {\n    if (area.sets.length === 1) {\n      const set = area.sets[0];\n      circles[set] = {\n        x: 1e10,\n        y: 1e10,\n        rowid: circles.length,\n        size: area.size,\n        radius: Math.sqrt(area.size / Math.PI)\n      };\n      setOverlaps[set] = [];\n    }\n  }\n\n  areas = areas.filter(a => a.sets.length === 2); // map each set to a list of all the other sets that overlap it\n\n  for (const current of areas) {\n    let weight = current.weight != null ? current.weight : 1.0;\n    const left = current.sets[0];\n    const right = current.sets[1]; // completely overlapped circles shouldn't be positioned early here\n\n    if (current.size + SMALL$1 >= Math.min(circles[left].size, circles[right].size)) {\n      weight = 0;\n    }\n\n    setOverlaps[left].push({\n      set: right,\n      size: current.size,\n      weight\n    });\n    setOverlaps[right].push({\n      set: left,\n      size: current.size,\n      weight\n    });\n  } // get list of most overlapped sets\n\n\n  const mostOverlapped = [];\n  Object.keys(setOverlaps).forEach(set => {\n    let size = 0;\n\n    for (let i = 0; i < setOverlaps[set].length; ++i) {\n      size += setOverlaps[set][i].size * setOverlaps[set][i].weight;\n    }\n\n    mostOverlapped.push({\n      set,\n      size\n    });\n  }); // sort by size desc\n\n  function sortOrder(a, b) {\n    return b.size - a.size;\n  }\n\n  mostOverlapped.sort(sortOrder); // keep track of what sets have been laid out\n\n  const positioned = {};\n\n  function isPositioned(element) {\n    return element.set in positioned;\n  }\n  /**\n   * adds a point to the output\n   * @param {{x: number, y: number}} point\n   * @param {number} index\n   */\n\n\n  function positionSet(point, index) {\n    circles[index].x = point.x;\n    circles[index].y = point.y;\n    positioned[index] = true;\n  } // add most overlapped set at (0,0)\n\n\n  positionSet({\n    x: 0,\n    y: 0\n  }, mostOverlapped[0].set); // get distances between all points. TODO, necessary?\n  // answer: probably not\n  // var distances = venn.getDistanceMatrices(circles, areas).distances;\n\n  for (let i = 1; i < mostOverlapped.length; ++i) {\n    const setIndex = mostOverlapped[i].set;\n    const overlap = setOverlaps[setIndex].filter(isPositioned);\n    const set = circles[setIndex];\n    overlap.sort(sortOrder);\n\n    if (overlap.length === 0) {\n      // this shouldn't happen anymore with addMissingAreas\n      throw 'ERROR: missing pairwise overlap information';\n    }\n    /** @type {{x: number, y: number}[]} */\n\n\n    const points = [];\n\n    for (var j = 0; j < overlap.length; ++j) {\n      // get appropriate distance from most overlapped already added set\n      const p1 = circles[overlap[j].set];\n      const d1 = distanceFromIntersectArea(set.radius, p1.radius, overlap[j].size); // sample positions at 90 degrees for maximum aesthetics\n\n      points.push({\n        x: p1.x + d1,\n        y: p1.y\n      });\n      points.push({\n        x: p1.x - d1,\n        y: p1.y\n      });\n      points.push({\n        y: p1.y + d1,\n        x: p1.x\n      });\n      points.push({\n        y: p1.y - d1,\n        x: p1.x\n      }); // if we have at least 2 overlaps, then figure out where the\n      // set should be positioned analytically and try those too\n\n      for (let k = j + 1; k < overlap.length; ++k) {\n        const p2 = circles[overlap[k].set];\n        const d2 = distanceFromIntersectArea(set.radius, p2.radius, overlap[k].size);\n        const extraPoints = circleCircleIntersection({\n          x: p1.x,\n          y: p1.y,\n          radius: d1\n        }, {\n          x: p2.x,\n          y: p2.y,\n          radius: d2\n        });\n        points.push(...extraPoints);\n      }\n    } // we have some candidate positions for the set, examine loss\n    // at each position to figure out where to put it at\n\n\n    let bestLoss = 1e50;\n    let bestPoint = points[0];\n\n    for (const point of points) {\n      circles[setIndex].x = point.x;\n      circles[setIndex].y = point.y;\n      const localLoss = loss(circles, areas);\n\n      if (localLoss < bestLoss) {\n        bestLoss = localLoss;\n        bestPoint = point;\n      }\n    }\n\n    positionSet(bestPoint, setIndex);\n  }\n\n  return circles;\n}\n/**\n * Given a bunch of sets, and the desired overlaps between these sets - computes\n * the distance from the actual overlaps to the desired overlaps. Note that\n * this method ignores overlaps of more than 2 circles\n * @param {{[key: string]: <{x: number, y: number, radius: number}>}} circles\n * @param {ReadonlyArray<{size: number, sets: ReadonlyArray<string>, weight?: number}>} overlaps\n * @returns {number}\n */\n\n\nfunction lossFunction(circles, overlaps) {\n  let output = 0;\n\n  for (const area of overlaps) {\n    if (area.sets.length === 1) {\n      continue;\n    }\n    /** @type {number} */\n\n\n    let overlap;\n\n    if (area.sets.length === 2) {\n      const left = circles[area.sets[0]];\n      const right = circles[area.sets[1]];\n      overlap = circleOverlap(left.radius, right.radius, distance(left, right));\n    } else {\n      overlap = intersectionArea(area.sets.map(d => circles[d]));\n    }\n\n    const weight = area.weight != null ? area.weight : 1.0;\n    output += weight * (overlap - area.size) * (overlap - area.size);\n  }\n\n  return output;\n}\n\nfunction logRatioLossFunction(circles, overlaps) {\n  let output = 0;\n\n  for (const area of overlaps) {\n    if (area.sets.length === 1) {\n      continue;\n    }\n    /** @type {number} */\n\n\n    let overlap;\n\n    if (area.sets.length === 2) {\n      const left = circles[area.sets[0]];\n      const right = circles[area.sets[1]];\n      overlap = circleOverlap(left.radius, right.radius, distance(left, right));\n    } else {\n      overlap = intersectionArea(area.sets.map(d => circles[d]));\n    }\n\n    const weight = area.weight != null ? area.weight : 1.0;\n    const differenceFromIdeal = Math.log((overlap + 1) / (area.size + 1));\n    output += weight * differenceFromIdeal * differenceFromIdeal;\n  }\n\n  return output;\n}\n/**\n * orientates a bunch of circles to point in orientation\n * @param {{x :number, y: number, radius: number}[]} circles\n * @param {number | undefined} orientation\n * @param {((a: {x :number, y: number, radius: number}, b: {x :number, y: number, radius: number}) => number) | undefined} orientationOrder\n */\n\n\nfunction orientateCircles(circles, orientation, orientationOrder) {\n  if (orientationOrder == null) {\n    circles.sort((a, b) => b.radius - a.radius);\n  } else {\n    circles.sort(orientationOrder);\n  } // shift circles so largest circle is at (0, 0)\n\n\n  if (circles.length > 0) {\n    const largestX = circles[0].x;\n    const largestY = circles[0].y;\n\n    for (const circle of circles) {\n      circle.x -= largestX;\n      circle.y -= largestY;\n    }\n  }\n\n  if (circles.length === 2) {\n    // if the second circle is a subset of the first, arrange so that\n    // it is off to one side. hack for https://github.com/benfred/venn.js/issues/120\n    const dist = distance(circles[0], circles[1]);\n\n    if (dist < Math.abs(circles[1].radius - circles[0].radius)) {\n      circles[1].x = circles[0].x + circles[0].radius - circles[1].radius - 1e-10;\n      circles[1].y = circles[0].y;\n    }\n  } // rotate circles so that second largest is at an angle of 'orientation'\n  // from largest\n\n\n  if (circles.length > 1) {\n    const rotation = Math.atan2(circles[1].x, circles[1].y) - orientation;\n    const c = Math.cos(rotation);\n    const s = Math.sin(rotation);\n\n    for (const circle of circles) {\n      const x = circle.x;\n      const y = circle.y;\n      circle.x = c * x - s * y;\n      circle.y = s * x + c * y;\n    }\n  } // mirror solution if third solution is above plane specified by\n  // first two circles\n\n\n  if (circles.length > 2) {\n    let angle = Math.atan2(circles[2].x, circles[2].y) - orientation;\n\n    while (angle < 0) {\n      angle += 2 * Math.PI;\n    }\n\n    while (angle > 2 * Math.PI) {\n      angle -= 2 * Math.PI;\n    }\n\n    if (angle > Math.PI) {\n      const slope = circles[1].y / (1e-10 + circles[1].x);\n\n      for (const circle of circles) {\n        var d = (circle.x + slope * circle.y) / (1 + slope * slope);\n        circle.x = 2 * d - circle.x;\n        circle.y = 2 * d * slope - circle.y;\n      }\n    }\n  }\n}\n/**\n *\n * @param {ReadonlyArray<{x: number, y: number, radius: number}>} circles\n * @returns {{x: number, y: number, radius: number}[][]}\n */\n\n\nfunction disjointCluster(circles) {\n  // union-find clustering to get disjoint sets\n  circles.forEach(circle => {\n    circle.parent = circle;\n  }); // path compression step in union find\n\n  function find(circle) {\n    if (circle.parent !== circle) {\n      circle.parent = find(circle.parent);\n    }\n\n    return circle.parent;\n  }\n\n  function union(x, y) {\n    const xRoot = find(x);\n    const yRoot = find(y);\n    xRoot.parent = yRoot;\n  } // get the union of all overlapping sets\n\n\n  for (let i = 0; i < circles.length; ++i) {\n    for (let j = i + 1; j < circles.length; ++j) {\n      const maxDistance = circles[i].radius + circles[j].radius;\n\n      if (distance(circles[i], circles[j]) + 1e-10 < maxDistance) {\n        union(circles[j], circles[i]);\n      }\n    }\n  } // find all the disjoint clusters and group them together\n\n  /** @type {Map<string, {x: number, y: number, radius: number}[]>} */\n\n\n  const disjointClusters = new Map();\n\n  for (let i = 0; i < circles.length; ++i) {\n    const setid = find(circles[i]).parent.setid;\n\n    if (!disjointClusters.has(setid)) {\n      disjointClusters.set(setid, []);\n    }\n\n    disjointClusters.get(setid).push(circles[i]);\n  } // cleanup bookkeeping\n\n\n  circles.forEach(circle => {\n    delete circle.parent;\n  }); // return in more usable form\n\n  return Array.from(disjointClusters.values());\n}\n/**\n * @param {ReadonlyArray<{x :number, y: number, radius: number}>} circles\n * @returns {{xRange: [number, number], yRange: [number, number]}}\n */\n\n\nfunction getBoundingBox(circles) {\n  const minMax = d => {\n    const hi = circles.reduce((acc, c) => Math.max(acc, c[d] + c.radius), Number.NEGATIVE_INFINITY);\n    const lo = circles.reduce((acc, c) => Math.min(acc, c[d] - c.radius), Number.POSITIVE_INFINITY);\n    return {\n      max: hi,\n      min: lo\n    };\n  };\n\n  return {\n    xRange: minMax('x'),\n    yRange: minMax('y')\n  };\n}\n/**\n *\n * @param {{[setid: string]: {x: number, y: number, radius: number}}} solution\n * @param {undefined | number} orientation\n * @param {((a: {x :number, y: number, radius: number}, b: {x :number, y: number, radius: number}) => number) | undefined} orientationOrder\n * @returns {{[setid: string]: {x: number, y: number, radius: number}}}\n */\n\n\nfunction normalizeSolution(solution, orientation, orientationOrder) {\n  if (orientation == null) {\n    orientation = Math.PI / 2;\n  } // work with a list instead of a dictionary, and take a copy so we\n  // don't mutate input\n\n\n  let circles = fromObjectNotation(solution).map(d => Object.assign({}, d)); // get all the disjoint clusters\n\n  const clusters = disjointCluster(circles); // orientate all disjoint sets, get sizes\n\n  for (const cluster of clusters) {\n    orientateCircles(cluster, orientation, orientationOrder);\n    const bounds = getBoundingBox(cluster);\n    cluster.size = (bounds.xRange.max - bounds.xRange.min) * (bounds.yRange.max - bounds.yRange.min);\n    cluster.bounds = bounds;\n  }\n\n  clusters.sort((a, b) => b.size - a.size); // orientate the largest at 0,0, and get the bounds\n\n  circles = clusters[0];\n  let returnBounds = circles.bounds;\n  const spacing = (returnBounds.xRange.max - returnBounds.xRange.min) / 50;\n  /**\n   * @param {ReadonlyArray<{x: number, y: number, radius: number, setid: string}>} cluster\n   * @param {boolean} right\n   * @param {boolean} bottom\n   */\n\n  function addCluster(cluster, right, bottom) {\n    if (!cluster) {\n      return;\n    }\n\n    const bounds = cluster.bounds;\n    /** @type {number} */\n\n    let xOffset;\n    /** @type {number} */\n\n    let yOffset;\n\n    if (right) {\n      xOffset = returnBounds.xRange.max - bounds.xRange.min + spacing;\n    } else {\n      xOffset = returnBounds.xRange.max - bounds.xRange.max;\n      const centreing = (bounds.xRange.max - bounds.xRange.min) / 2 - (returnBounds.xRange.max - returnBounds.xRange.min) / 2;\n\n      if (centreing < 0) {\n        xOffset += centreing;\n      }\n    }\n\n    if (bottom) {\n      yOffset = returnBounds.yRange.max - bounds.yRange.min + spacing;\n    } else {\n      yOffset = returnBounds.yRange.max - bounds.yRange.max;\n      const centreing = (bounds.yRange.max - bounds.yRange.min) / 2 - (returnBounds.yRange.max - returnBounds.yRange.min) / 2;\n\n      if (centreing < 0) {\n        yOffset += centreing;\n      }\n    }\n\n    for (const c of cluster) {\n      c.x += xOffset;\n      c.y += yOffset;\n      circles.push(c);\n    }\n  }\n\n  let index = 1;\n\n  while (index < clusters.length) {\n    addCluster(clusters[index], true, false);\n    addCluster(clusters[index + 1], false, true);\n    addCluster(clusters[index + 2], true, true);\n    index += 3; // have one cluster (in top left). lay out next three relative\n    // to it in a grid\n\n    returnBounds = getBoundingBox(circles);\n  } // convert back to solution form\n\n\n  return toObjectNotation(circles);\n}\n/**\n * Scales a solution from venn.venn or venn.greedyLayout such that it fits in\n * a rectangle of width/height - with padding around the borders. also\n * centers the diagram in the available space at the same time.\n * If the scale parameter is not null, this automatic scaling is ignored in favor of this custom one\n * @param {{[setid: string]: {x: number, y: number, radius: number}}} solution\n * @param {number} width\n * @param {number} height\n * @param {number} padding\n * @param {boolean} scaleToFit\n * @returns {{[setid: string]: {x: number, y: number, radius: number}}}\n */\n\n\nfunction scaleSolution(solution, width, height, padding, scaleToFit) {\n  const circles = fromObjectNotation(solution);\n  width -= 2 * padding;\n  height -= 2 * padding;\n  const {\n    xRange,\n    yRange\n  } = getBoundingBox(circles);\n\n  if (xRange.max === xRange.min || yRange.max === yRange.min) {\n    console.log('not scaling solution: zero size detected');\n    return solution;\n  }\n  /** @type {number} */\n\n\n  let xScaling;\n  /** @type {number} */\n\n  let yScaling;\n\n  if (scaleToFit) {\n    const toScaleDiameter = Math.sqrt(scaleToFit / Math.PI) * 2;\n    xScaling = width / toScaleDiameter;\n    yScaling = height / toScaleDiameter;\n  } else {\n    xScaling = width / (xRange.max - xRange.min);\n    yScaling = height / (yRange.max - yRange.min);\n  }\n\n  const scaling = Math.min(yScaling, xScaling); // while we're at it, center the diagram too\n\n  const xOffset = (width - (xRange.max - xRange.min) * scaling) / 2;\n  const yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;\n  return toObjectNotation(circles.map(circle => ({\n    radius: scaling * circle.radius,\n    x: padding + xOffset + (circle.x - xRange.min) * scaling,\n    y: padding + yOffset + (circle.y - yRange.min) * scaling,\n    setid: circle.setid\n  })));\n}\n/**\n * @param {readonly {x: number, y: number, radius: number, setid: string}[]} circles\n * @returns {{[setid: string]: {x: number, y: number, radius: number}}}\n */\n\n\nfunction toObjectNotation(circles) {\n  /** @type {{[setid: string]: {x: number, y: number, radius: number}}} */\n  const r = {};\n\n  for (const circle of circles) {\n    r[circle.setid] = circle;\n  }\n\n  return r;\n}\n/**\n * @param {{[setid: string]: {x: number, y: number, radius: number}}} solution\n * @returns {{x: number, y: number, radius: number, setid: string}[]}}\n */\n\n\nfunction fromObjectNotation(solution) {\n  const setids = Object.keys(solution);\n  return setids.map(id => Object.assign(solution[id], {\n    setid: id\n  }));\n}\n/*global console:true*/\n\n/**\n * VennDiagram includes an optional `options` parameter containing the following option(s):\n *\n * `colourScheme: Array<String>`\n * A list of color values to be applied when coloring diagram circles.\n *\n * `symmetricalTextCentre: Boolean`\n * Whether to symmetrically center each circle's text horizontally and vertically.\n * Defaults to `false`.\n *\n * `textFill: String`\n * The color to be applied to the text within each circle.\n *\n * @param {object} options\n */\n\n\nfunction VennDiagram() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  let useViewBox = false,\n      width = 600,\n      height = 350,\n      padding = 15,\n      duration = 1000,\n      orientation = Math.PI / 2,\n      normalize = true,\n      scaleToFit = null,\n      wrap = true,\n      styled = true,\n      fontSize = null,\n      orientationOrder = null,\n      distinct = false,\n      round = null,\n      symmetricalTextCentre = options && options.symmetricalTextCentre ? options.symmetricalTextCentre : false,\n      // mimic the behaviour of d3.scale.category10 from the previous\n  // version of d3\n  colourMap = {},\n      // so this is the same as d3.schemeCategory10, which is only defined in d3 4.0\n  // since we can support older versions of d3 as long as we don't force this,\n  // I'm hackily redefining below. TODO: remove this and change to d3.schemeCategory10\n  colourScheme = options && options.colourScheme ? options.colourScheme : options && options.colorScheme ? options.colorScheme : ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'],\n      colourIndex = 0,\n      colours = function (key) {\n    if (key in colourMap) {\n      return colourMap[key];\n    }\n\n    var ret = colourMap[key] = colourScheme[colourIndex];\n    colourIndex += 1;\n\n    if (colourIndex >= colourScheme.length) {\n      colourIndex = 0;\n    }\n\n    return ret;\n  },\n      layoutFunction = venn,\n      loss = lossFunction;\n\n  function chart(selection) {\n    let data = selection.datum(); // handle 0-sized sets by removing from input\n\n    const toRemove = new Set();\n    data.forEach(datum => {\n      if (datum.size == 0 && datum.sets.length == 1) {\n        toRemove.add(datum.sets[0]);\n      }\n    });\n    data = data.filter(datum => !datum.sets.some(set => toRemove.has(set)));\n    let circles = {};\n    let textCentres = {};\n\n    if (data.length > 0) {\n      let solution = layoutFunction(data, {\n        lossFunction: loss,\n        distinct\n      });\n\n      if (normalize) {\n        solution = normalizeSolution(solution, orientation, orientationOrder);\n      }\n\n      circles = scaleSolution(solution, width, height, padding, scaleToFit);\n      textCentres = computeTextCentres(circles, data, symmetricalTextCentre);\n    } // Figure out the current label for each set. These can change\n    // and D3 won't necessarily update (fixes https://github.com/benfred/venn.js/issues/103)\n\n\n    const labels = {};\n    data.forEach(datum => {\n      if (datum.label) {\n        labels[datum.sets] = datum.label;\n      }\n    });\n\n    function label(d) {\n      if (d.sets in labels) {\n        return labels[d.sets];\n      }\n\n      if (d.sets.length == 1) {\n        return '' + d.sets[0];\n      }\n    } // create svg if not already existing\n\n\n    selection.selectAll('svg').data([circles]).enter().append('svg');\n    const svg = selection.select('svg');\n\n    if (useViewBox) {\n      svg.attr('viewBox', `0 0 ${width} ${height}`);\n    } else {\n      svg.attr('width', width).attr('height', height);\n    } // to properly transition intersection areas, we need the\n    // previous circles locations. load from elements\n\n\n    const previous = {};\n    let hasPrevious = false;\n    svg.selectAll('.venn-area path').each(function (d) {\n      const path = this.getAttribute('d');\n\n      if (d.sets.length == 1 && path && !distinct) {\n        hasPrevious = true;\n        previous[d.sets[0]] = circleFromPath(path);\n      }\n    }); // interpolate intersection area paths between previous and\n    // current paths\n\n    function pathTween(d) {\n      return t => {\n        const c = d.sets.map(set => {\n          let start = previous[set];\n          let end = circles[set];\n\n          if (!start) {\n            start = {\n              x: width / 2,\n              y: height / 2,\n              radius: 1\n            };\n          }\n\n          if (!end) {\n            end = {\n              x: width / 2,\n              y: height / 2,\n              radius: 1\n            };\n          }\n\n          return {\n            x: start.x * (1 - t) + end.x * t,\n            y: start.y * (1 - t) + end.y * t,\n            radius: start.radius * (1 - t) + end.radius * t\n          };\n        });\n        return intersectionAreaPath(c, round);\n      };\n    } // update data, joining on the set ids\n\n\n    const nodes = svg.selectAll('.venn-area').data(data, d => d.sets); // create new nodes\n\n    const enter = nodes.enter().append('g').attr('class', d => `venn-area venn-${d.sets.length == 1 ? 'circle' : 'intersection'}${d.colour || d.color ? ' venn-coloured' : ''}`).attr('data-venn-sets', d => d.sets.join('_'));\n    const enterPath = enter.append('path');\n    const enterText = enter.append('text').attr('class', 'label').text(d => label(d)).attr('text-anchor', 'middle').attr('dy', '.35em').attr('x', width / 2).attr('y', height / 2); // apply minimal style if wanted\n\n    if (styled) {\n      enterPath.style('fill-opacity', '0').filter(d => d.sets.length == 1).style('fill', d => d.colour ? d.colour : d.color ? d.color : colours(d.sets)).style('fill-opacity', '.25');\n      enterText.style('fill', d => {\n        if (d.colour || d.color) {\n          return '#FFF';\n        }\n\n        if (options.textFill) {\n          return options.textFill;\n        }\n\n        return d.sets.length == 1 ? colours(d.sets) : '#444';\n      });\n    }\n\n    function asTransition(s) {\n      if (typeof s.transition === 'function') {\n        return s.transition('venn').duration(duration);\n      }\n\n      return s;\n    } // update existing, using pathTween if necessary\n\n\n    let update = selection;\n\n    if (hasPrevious && typeof update.transition === 'function') {\n      update = asTransition(selection);\n      update.selectAll('path').attrTween('d', pathTween);\n    } else {\n      update.selectAll('path').attr('d', d => intersectionAreaPath(d.sets.map(set => circles[set])), round);\n    }\n\n    const updateText = update.selectAll('text').filter(d => d.sets in textCentres).text(d => label(d)).attr('x', d => Math.floor(textCentres[d.sets].x)).attr('y', d => Math.floor(textCentres[d.sets].y));\n\n    if (wrap) {\n      if (hasPrevious) {\n        // d3 4.0 uses 'on' for events on transitions,\n        // but d3 3.0 used 'each' instead. switch appropriately\n        if ('on' in updateText) {\n          updateText.on('end', wrapText(circles, label));\n        } else {\n          updateText.each('end', wrapText(circles, label));\n        }\n      } else {\n        updateText.each(wrapText(circles, label));\n      }\n    } // remove old\n\n\n    const exit = asTransition(nodes.exit()).remove();\n\n    if (typeof nodes.transition === 'function') {\n      exit.selectAll('path').attrTween('d', pathTween);\n    }\n\n    const exitText = exit.selectAll('text').attr('x', width / 2).attr('y', height / 2); // if we've been passed a fontSize explicitly, use it to\n    // transition\n\n    if (fontSize !== null) {\n      enterText.style('font-size', '0px');\n      updateText.style('font-size', fontSize);\n      exitText.style('font-size', '0px');\n    }\n\n    return {\n      circles,\n      textCentres,\n      nodes,\n      enter,\n      update,\n      exit\n    };\n  }\n\n  chart.wrap = function (_) {\n    if (!arguments.length) return wrap;\n    wrap = _;\n    return chart;\n  };\n\n  chart.useViewBox = function () {\n    useViewBox = true;\n    return chart;\n  };\n\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n\n  chart.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return chart;\n  };\n\n  chart.padding = function (_) {\n    if (!arguments.length) return padding;\n    padding = _;\n    return chart;\n  };\n\n  chart.distinct = function (_) {\n    if (!arguments.length) return distinct;\n    distinct = _;\n    return chart;\n  };\n\n  chart.colours = function (_) {\n    if (!arguments.length) return colours;\n    colours = _;\n    return chart;\n  };\n\n  chart.colors = function (_) {\n    if (!arguments.length) return colors;\n    colours = _;\n    return chart;\n  };\n\n  chart.fontSize = function (_) {\n    if (!arguments.length) return fontSize;\n    fontSize = _;\n    return chart;\n  };\n\n  chart.round = function (_) {\n    if (!arguments.length) return round;\n    round = _;\n    return chart;\n  };\n\n  chart.duration = function (_) {\n    if (!arguments.length) return duration;\n    duration = _;\n    return chart;\n  };\n\n  chart.layoutFunction = function (_) {\n    if (!arguments.length) return layoutFunction;\n    layoutFunction = _;\n    return chart;\n  };\n\n  chart.normalize = function (_) {\n    if (!arguments.length) return normalize;\n    normalize = _;\n    return chart;\n  };\n\n  chart.scaleToFit = function (_) {\n    if (!arguments.length) return scaleToFit;\n    scaleToFit = _;\n    return chart;\n  };\n\n  chart.styled = function (_) {\n    if (!arguments.length) return styled;\n    styled = _;\n    return chart;\n  };\n\n  chart.orientation = function (_) {\n    if (!arguments.length) return orientation;\n    orientation = _;\n    return chart;\n  };\n\n  chart.orientationOrder = function (_) {\n    if (!arguments.length) return orientationOrder;\n    orientationOrder = _;\n    return chart;\n  };\n\n  chart.lossFunction = function (_) {\n    if (!arguments.length) return loss;\n    loss = _ === 'default' ? lossFunction : _ === 'logRatio' ? logRatioLossFunction : _;\n    return chart;\n  };\n\n  return chart;\n} // sometimes text doesn't fit inside the circle, if thats the case lets wrap\n// the text here such that it fits\n// todo: looks like this might be merged into d3 (\n// https://github.com/mbostock/d3/issues/1642),\n// also worth checking out is\n// http://engineering.findthebest.com/wrapping-axis-labels-in-d3-js/\n// this seems to be one of those things that should be easy but isn't\n\n\nfunction wrapText(circles, labeller) {\n  return function (data) {\n    const text = this;\n    const width = circles[data.sets[0]].radius || 50;\n    const label = labeller(data) || '';\n    const words = label.split(/\\s+/).reverse();\n    const maxLines = 3;\n    const minChars = (label.length + words.length) / maxLines;\n    let word = words.pop();\n    let line = [word];\n    let lineNumber = 0;\n    const lineHeight = 1.1; // ems\n\n    text.textContent = null; // clear\n\n    const tspans = [];\n\n    function append(word) {\n      const tspan = text.ownerDocument.createElementNS(text.namespaceURI, 'tspan');\n      tspan.textContent = word;\n      tspans.push(tspan);\n      text.append(tspan);\n      return tspan;\n    }\n\n    let tspan = append(word);\n\n    while (true) {\n      word = words.pop();\n\n      if (!word) {\n        break;\n      }\n\n      line.push(word);\n      const joined = line.join(' ');\n      tspan.textContent = joined;\n\n      if (joined.length > minChars && tspan.getComputedTextLength() > width) {\n        line.pop();\n        tspan.textContent = line.join(' ');\n        line = [word];\n        tspan = append(word);\n        lineNumber++;\n      }\n    }\n\n    const initial = 0.35 - lineNumber * lineHeight / 2;\n    const x = text.getAttribute('x');\n    const y = text.getAttribute('y');\n    tspans.forEach((t, i) => {\n      t.setAttribute('x', x);\n      t.setAttribute('y', y);\n      t.setAttribute('dy', `${initial + i * lineHeight}em`);\n    });\n  };\n}\n/**\n *\n * @param {{x: number, y: number}} current\n * @param {ReadonlyArray<{x: number, y: number}>} interior\n * @param {ReadonlyArray<{x: number, y: number}>} exterior\n * @returns {number}\n */\n\n\nfunction circleMargin(current, interior, exterior) {\n  let margin = interior[0].radius - distance(interior[0], current);\n\n  for (let i = 1; i < interior.length; ++i) {\n    const m = interior[i].radius - distance(interior[i], current);\n\n    if (m <= margin) {\n      margin = m;\n    }\n  }\n\n  for (let i = 0; i < exterior.length; ++i) {\n    const m = distance(exterior[i], current) - exterior[i].radius;\n\n    if (m <= margin) {\n      margin = m;\n    }\n  }\n\n  return margin;\n}\n/**\n * compute the center of some circles by maximizing the margin of\n * the center point relative to the circles (interior) after subtracting\n * nearby circles (exterior)\n * @param {readonly {x: number, y: number, radius: number}[]} interior\n * @param {readonly {x: number, y: number, radius: number}[]} exterior\n * @param {boolean} symmetricalTextCentre\n * @returns {{x:number, y: number}}\n */\n\n\nfunction computeTextCentre(interior, exterior, symmetricalTextCentre) {\n  // get an initial estimate by sampling around the interior circles\n  // and taking the point with the biggest margin\n\n  /** @type {{x: number, y: number}[]} */\n  const points = [];\n\n  for (const c of interior) {\n    points.push({\n      x: c.x,\n      y: c.y\n    });\n    points.push({\n      x: c.x + c.radius / 2,\n      y: c.y\n    });\n    points.push({\n      x: c.x - c.radius / 2,\n      y: c.y\n    });\n    points.push({\n      x: c.x,\n      y: c.y + c.radius / 2\n    });\n    points.push({\n      x: c.x,\n      y: c.y - c.radius / 2\n    });\n  }\n\n  let initial = points[0];\n  let margin = circleMargin(points[0], interior, exterior);\n\n  for (let i = 1; i < points.length; ++i) {\n    const m = circleMargin(points[i], interior, exterior);\n\n    if (m >= margin) {\n      initial = points[i];\n      margin = m;\n    }\n  } // maximize the margin numerically\n\n\n  const solution = nelderMead(p => -1 * circleMargin({\n    x: p[0],\n    y: p[1]\n  }, interior, exterior), [initial.x, initial.y], {\n    maxIterations: 500,\n    minErrorDelta: 1e-10\n  }).x;\n  const ret = {\n    x: symmetricalTextCentre ? 0 : solution[0],\n    y: solution[1]\n  }; // check solution, fallback as needed (happens if fully overlapped\n  // etc)\n\n  let valid = true;\n\n  for (const i of interior) {\n    if (distance(ret, i) > i.radius) {\n      valid = false;\n      break;\n    }\n  }\n\n  for (const e of exterior) {\n    if (distance(ret, e) < e.radius) {\n      valid = false;\n      break;\n    }\n  }\n\n  if (valid) {\n    return ret;\n  }\n\n  if (interior.length == 1) {\n    return {\n      x: interior[0].x,\n      y: interior[0].y\n    };\n  }\n\n  const areaStats = {};\n  intersectionArea(interior, areaStats);\n\n  if (areaStats.arcs.length === 0) {\n    return {\n      x: 0,\n      y: -1000,\n      disjoint: true\n    };\n  }\n\n  if (areaStats.arcs.length == 1) {\n    return {\n      x: areaStats.arcs[0].circle.x,\n      y: areaStats.arcs[0].circle.y\n    };\n  }\n\n  if (exterior.length) {\n    // try again without other circles\n    return computeTextCentre(interior, []);\n  } // take average of all the points in the intersection\n  // polygon. this should basically never happen\n  // and has some issues:\n  // https://github.com/benfred/venn.js/issues/48#issuecomment-146069777\n\n\n  return getCenter(areaStats.arcs.map(a => a.p1));\n} // given a dictionary of {setid : circle}, returns\n// a dictionary of setid to list of circles that completely overlap it\n\n\nfunction getOverlappingCircles(circles) {\n  const ret = {};\n  const circleids = Object.keys(circles);\n\n  for (const circleid of circleids) {\n    ret[circleid] = [];\n  }\n\n  for (let i = 0; i < circleids.length; i++) {\n    const ci = circleids[i];\n    const a = circles[ci];\n\n    for (let j = i + 1; j < circleids.length; ++j) {\n      const cj = circleids[j];\n      const b = circles[cj];\n      const d = distance(a, b);\n\n      if (d + b.radius <= a.radius + 1e-10) {\n        ret[cj].push(ci);\n      } else if (d + a.radius <= b.radius + 1e-10) {\n        ret[ci].push(cj);\n      }\n    }\n  }\n\n  return ret;\n}\n\nfunction computeTextCentres(circles, areas, symmetricalTextCentre) {\n  const ret = {};\n  const overlapped = getOverlappingCircles(circles);\n\n  for (let i = 0; i < areas.length; ++i) {\n    const area = areas[i].sets;\n    const areaids = {};\n    const exclude = {};\n\n    for (let j = 0; j < area.length; ++j) {\n      areaids[area[j]] = true;\n      const overlaps = overlapped[area[j]]; // keep track of any circles that overlap this area,\n      // and don't consider for purposes of computing the text\n      // centre\n\n      for (let k = 0; k < overlaps.length; ++k) {\n        exclude[overlaps[k]] = true;\n      }\n    }\n\n    const interior = [];\n    const exterior = [];\n\n    for (let setid in circles) {\n      if (setid in areaids) {\n        interior.push(circles[setid]);\n      } else if (!(setid in exclude)) {\n        exterior.push(circles[setid]);\n      }\n    }\n\n    const centre = computeTextCentre(interior, exterior, symmetricalTextCentre);\n    ret[area] = centre;\n\n    if (centre.disjoint && areas[i].size > 0) {\n      console.log('WARNING: area ' + area + ' not represented on screen');\n    }\n  }\n\n  return ret;\n} // sorts all areas in the venn diagram, so that\n// a particular area is on top (relativeTo) - and\n// all other areas are so that the smallest areas are on top\n\n\nfunction sortAreas(div, relativeTo) {\n  // figure out sets that are completely overlapped by relativeTo\n  const overlaps = getOverlappingCircles(div.selectAll('svg').datum());\n  const exclude = new Set();\n\n  for (const check of relativeTo.sets) {\n    for (let setid in overlaps) {\n      const overlap = overlaps[setid];\n\n      for (let j = 0; j < overlap.length; ++j) {\n        if (overlap[j] == check) {\n          exclude.add(setid);\n          break;\n        }\n      }\n    }\n  } // checks that all sets are in exclude;\n\n\n  function shouldExclude(sets) {\n    return sets.every(set => !exclude.has(set));\n  } // need to sort div's so that Z order is correct\n\n\n  div.selectAll('g').sort((a, b) => {\n    // highest order set intersections first\n    if (a.sets.length != b.sets.length) {\n      return a.sets.length - b.sets.length;\n    }\n\n    if (a == relativeTo) {\n      return shouldExclude(b.sets) ? -1 : 1;\n    }\n\n    if (b == relativeTo) {\n      return shouldExclude(a.sets) ? 1 : -1;\n    } // finally by size\n\n\n    return b.size - a.size;\n  });\n}\n/**\n * @param {number} x\n * @param {number} y\n * @param {number} r\n * @returns {string}\n */\n\n\nfunction circlePath(x, y, r) {\n  const ret = [];\n  ret.push('\\nM', x, y);\n  ret.push('\\nm', -r, 0);\n  ret.push('\\na', r, r, 0, 1, 0, r * 2, 0);\n  ret.push('\\na', r, r, 0, 1, 0, -r * 2, 0);\n  return ret.join(' ');\n}\n/**\n * inverse of the circlePath function, returns a circle object from an svg path\n * @param {string} path\n * @returns {{x: number, y: number, radius: number}}\n */\n\n\nfunction circleFromPath(path) {\n  const tokens = path.split(' ');\n  return {\n    x: Number.parseFloat(tokens[1]),\n    y: Number.parseFloat(tokens[2]),\n    radius: -Number.parseFloat(tokens[4])\n  };\n}\n\nfunction intersectionAreaArcs(circles) {\n  if (circles.length === 0) {\n    return [];\n  }\n\n  const stats = {};\n  intersectionArea(circles, stats);\n  return stats.arcs;\n}\n\nfunction arcsToPath(arcs, round) {\n  if (arcs.length === 0) {\n    return 'M 0 0';\n  }\n\n  const rFactor = Math.pow(10, round || 0);\n  const r = round != null ? v => Math.round(v * rFactor) / rFactor : v => v;\n\n  if (arcs.length == 1) {\n    const circle = arcs[0].circle;\n    return circlePath(r(circle.x), r(circle.y), r(circle.radius));\n  } // draw path around arcs\n\n\n  const ret = ['\\nM', r(arcs[0].p2.x), r(arcs[0].p2.y)];\n\n  for (const arc of arcs) {\n    const radius = r(arc.circle.radius);\n    ret.push('\\nA', radius, radius, 0, arc.large ? 1 : 0, arc.sweep ? 1 : 0, r(arc.p1.x), r(arc.p1.y));\n  }\n\n  return ret.join(' ');\n}\n/**\n * returns a svg path of the intersection area of a bunch of circles\n * @param {ReadonlyArray<{x: number, y: number, radius: number}>} circles\n * @returns {string}\n */\n\n\nfunction intersectionAreaPath(circles, round) {\n  return arcsToPath(intersectionAreaArcs(circles), round);\n}\n\nfunction layout(data) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    lossFunction: loss,\n    layoutFunction: layout = venn,\n    normalize = true,\n    orientation = Math.PI / 2,\n    orientationOrder,\n    width = 600,\n    height = 350,\n    padding = 15,\n    scaleToFit = false,\n    symmetricalTextCentre = false,\n    distinct,\n    round = 2\n  } = options;\n  let solution = layout(data, {\n    lossFunction: loss === 'default' || !loss ? lossFunction : loss === 'logRatio' ? logRatioLossFunction : loss,\n    distinct\n  });\n\n  if (normalize) {\n    solution = normalizeSolution(solution, orientation, orientationOrder);\n  }\n\n  const circles = scaleSolution(solution, width, height, padding, scaleToFit);\n  const textCentres = computeTextCentres(circles, data, symmetricalTextCentre);\n  const circleLookup = new Map(Object.keys(circles).map(set => [set, {\n    set,\n    x: circles[set].x,\n    y: circles[set].y,\n    radius: circles[set].radius\n  }]));\n  const helpers = data.map(area => {\n    const circles = area.sets.map(s => circleLookup.get(s));\n    const arcs = intersectionAreaArcs(circles);\n    const path = arcsToPath(arcs, round);\n    return {\n      circles,\n      arcs,\n      path,\n      area,\n      has: new Set(area.sets)\n    };\n  });\n\n  function genDistinctPath(sets) {\n    let r = '';\n\n    for (const e of helpers) {\n      if (e.has.size > sets.length && sets.every(s => e.has.has(s))) {\n        r += ' ' + e.path;\n      }\n    }\n\n    return r;\n  }\n\n  return helpers.map(_ref => {\n    let {\n      circles,\n      arcs,\n      path,\n      area\n    } = _ref;\n    return {\n      data: area,\n      text: textCentres[area.sets],\n      circles,\n      arcs,\n      path,\n      distinctPath: path + genDistinctPath(area.sets)\n    };\n  });\n}\n\nexport { VennDiagram, bestInitialLayout, circleArea, circleCircleIntersection, circleFromPath, circleOverlap, circlePath, computeTextCentre, computeTextCentres, disjointCluster, distance, distanceFromIntersectArea, greedyLayout, intersectionArea, intersectionAreaPath, layout, logRatioLossFunction, lossFunction, normalizeSolution, scaleSolution, sortAreas, venn, wrapText };","map":{"version":3,"sources":["/Users/xuehui/Desktop/NUS_Stuff/AY2122.1_Y4S1/Capstone/lta-visualization/frontend/node_modules/@upsetjs/venn.js/build/venn.esm.js"],"names":["nelderMead","bisect","norm2","zeros","conjugateGradient","scale","zerosM","SMALL","intersectionArea","circles","stats","intersectionPoints","getIntersectionPoints","innerPoints","filter","p","containedInCircles","arcArea","polygonArea","arcs","length","center","getCenter","i","angle","Math","atan2","x","y","sort","a","b","p2","p1","midPoint","arc","j","parentIndex","includes","circle","a1","a2","angleDiff","PI","width","distance","radius","sin","cos","large","sweep","push","circleArea","smallest","disjoint","abs","area","point","every","ret","intersect","circleCircleIntersection","r","acos","sqrt","circleOverlap","r1","r2","d","min","w1","w2","h","x0","y0","rx","ry","points","venn","sets","parameters","maxIterations","initialLayout","bestInitialLayout","loss","lossFunction","areas","addMissingAreas","setids","Object","keys","initial","setid","solution","values","current","positions","SMALL$1","distanceFromIntersectArea","overlap","distinct","map","s","assign","toKey","arr","join","count","Map","si","String","set","size","get","sj","k1","k2","ids","pairs","Set","add","has","getDistanceMatrices","distances","constraints","forEach","left","right","c","constrainedMDSGradient","fxprime","xi","yi","xj","yj","dij","constraint","squaredDistance","delta","params","greedyLayout","constrained","constrainedMDSLayout","constrainedLoss","greedyLoss","restarts","norm","row","value","obj","best","random","fx","history","setOverlaps","rowid","weight","mostOverlapped","sortOrder","positioned","isPositioned","element","positionSet","index","setIndex","d1","k","d2","extraPoints","bestLoss","bestPoint","localLoss","overlaps","output","logRatioLossFunction","differenceFromIdeal","log","orientateCircles","orientation","orientationOrder","largestX","largestY","dist","rotation","slope","disjointCluster","parent","find","union","xRoot","yRoot","maxDistance","disjointClusters","Array","from","getBoundingBox","minMax","hi","reduce","acc","max","Number","NEGATIVE_INFINITY","lo","POSITIVE_INFINITY","xRange","yRange","normalizeSolution","fromObjectNotation","clusters","cluster","bounds","returnBounds","spacing","addCluster","bottom","xOffset","yOffset","centreing","toObjectNotation","scaleSolution","height","padding","scaleToFit","console","xScaling","yScaling","toScaleDiameter","scaling","id","VennDiagram","options","useViewBox","duration","normalize","wrap","styled","fontSize","round","symmetricalTextCentre","colourMap","colourScheme","colorScheme","colourIndex","colours","key","layoutFunction","chart","selection","data","datum","toRemove","some","textCentres","computeTextCentres","labels","label","selectAll","enter","append","svg","select","attr","previous","hasPrevious","each","path","getAttribute","circleFromPath","pathTween","t","start","end","intersectionAreaPath","nodes","colour","color","enterPath","enterText","text","style","textFill","asTransition","transition","update","attrTween","updateText","floor","on","wrapText","exit","remove","exitText","_","arguments","colors","labeller","words","split","reverse","maxLines","minChars","word","pop","line","lineNumber","lineHeight","textContent","tspans","tspan","ownerDocument","createElementNS","namespaceURI","joined","getComputedTextLength","setAttribute","circleMargin","interior","exterior","margin","m","computeTextCentre","minErrorDelta","valid","e","areaStats","getOverlappingCircles","circleids","circleid","ci","cj","overlapped","areaids","exclude","centre","sortAreas","div","relativeTo","check","shouldExclude","circlePath","tokens","parseFloat","intersectionAreaArcs","arcsToPath","rFactor","pow","v","layout","circleLookup","helpers","genDistinctPath","distinctPath"],"mappings":"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","sourcesContent":["import { nelderMead, bisect, norm2, zeros, conjugateGradient, scale, zerosM } from 'fmin';\n\nconst SMALL = 1e-10;\n\n/**\n * Returns the intersection area of a bunch of circles (where each circle\n * is an object having an x,y and radius property)\n * @param {ReadonlyArray<{x: number, y: number, radius: number}>} circles\n * @param {undefined | { area?: number, arcArea?: number, polygonArea?: number, arcs?: ReadonlyArray<{ circle: {x: number, y: number, radius: number}, width: number, p1: {x: number, y: number}, p2: {x: number, y: number} }>, innerPoints: ReadonlyArray<{\n    x: number;\n    y: number;\n    parentIndex: [number, number];\n}>, intersectionPoints: ReadonlyArray<{\n  x: number;\n  y: number;\n  parentIndex: [number, number];\n}> }} stats\n * @returns {number}\n */\nfunction intersectionArea(circles, stats) {\n  // get all the intersection points of the circles\n  const intersectionPoints = getIntersectionPoints(circles);\n\n  // filter out points that aren't included in all the circles\n  const innerPoints = intersectionPoints.filter((p) => containedInCircles(p, circles));\n\n  let arcArea = 0;\n  let polygonArea = 0;\n  /** @type {{ circle: {x: number, y: number, radius: number}, width: number, p1: {x: number, y: number}, p2: {x: number, y: number} }[]} */\n  const arcs = [];\n\n  // if we have intersection points that are within all the circles,\n  // then figure out the area contained by them\n  if (innerPoints.length > 1) {\n    // sort the points by angle from the center of the polygon, which lets\n    // us just iterate over points to get the edges\n    const center = getCenter(innerPoints);\n    for (let i = 0; i < innerPoints.length; ++i) {\n      const p = innerPoints[i];\n      p.angle = Math.atan2(p.x - center.x, p.y - center.y);\n    }\n    innerPoints.sort((a, b) => b.angle - a.angle);\n\n    // iterate over all points, get arc between the points\n    // and update the areas\n    let p2 = innerPoints[innerPoints.length - 1];\n    for (let i = 0; i < innerPoints.length; ++i) {\n      const p1 = innerPoints[i];\n\n      // polygon area updates easily ...\n      polygonArea += (p2.x + p1.x) * (p1.y - p2.y);\n\n      // updating the arc area is a little more involved\n      const midPoint = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };\n      /** @types null | { circle: {x: number, y: number, radius: number}, width: number, p1: {x: number, y: number}, p2: {x: number, y: number} } */\n      let arc = null;\n\n      for (let j = 0; j < p1.parentIndex.length; ++j) {\n        if (p2.parentIndex.includes(p1.parentIndex[j])) {\n          // figure out the angle halfway between the two points\n          // on the current circle\n          const circle = circles[p1.parentIndex[j]];\n          const a1 = Math.atan2(p1.x - circle.x, p1.y - circle.y);\n          const a2 = Math.atan2(p2.x - circle.x, p2.y - circle.y);\n\n          let angleDiff = a2 - a1;\n          if (angleDiff < 0) {\n            angleDiff += 2 * Math.PI;\n          }\n\n          // and use that angle to figure out the width of the\n          // arc\n          const a = a2 - angleDiff / 2;\n          let width = distance(midPoint, {\n            x: circle.x + circle.radius * Math.sin(a),\n            y: circle.y + circle.radius * Math.cos(a),\n          });\n\n          // clamp the width to the largest is can actually be\n          // (sometimes slightly overflows because of FP errors)\n          if (width > circle.radius * 2) {\n            width = circle.radius * 2;\n          }\n\n          // pick the circle whose arc has the smallest width\n          if (arc == null || arc.width > width) {\n            arc = { circle, width, p1, p2, large: width > circle.radius, sweep: true };\n          }\n        }\n      }\n\n      if (arc != null) {\n        arcs.push(arc);\n        arcArea += circleArea(arc.circle.radius, arc.width);\n        p2 = p1;\n      }\n    }\n  } else {\n    // no intersection points, is either disjoint - or is completely\n    // overlapped. figure out which by examining the smallest circle\n    let smallest = circles[0];\n    for (let i = 1; i < circles.length; ++i) {\n      if (circles[i].radius < smallest.radius) {\n        smallest = circles[i];\n      }\n    }\n\n    // make sure the smallest circle is completely contained in all\n    // the other circles\n    let disjoint = false;\n    for (let i = 0; i < circles.length; ++i) {\n      if (distance(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {\n        disjoint = true;\n        break;\n      }\n    }\n\n    if (disjoint) {\n      arcArea = polygonArea = 0;\n    } else {\n      arcArea = smallest.radius * smallest.radius * Math.PI;\n      arcs.push({\n        circle: smallest,\n        p1: { x: smallest.x, y: smallest.y + smallest.radius },\n        p2: { x: smallest.x - SMALL, y: smallest.y + smallest.radius },\n        width: smallest.radius * 2,\n        large: true,\n        sweep: true,\n      });\n    }\n  }\n\n  polygonArea /= 2;\n\n  if (stats) {\n    stats.area = arcArea + polygonArea;\n    stats.arcArea = arcArea;\n    stats.polygonArea = polygonArea;\n    stats.arcs = arcs;\n    stats.innerPoints = innerPoints;\n    stats.intersectionPoints = intersectionPoints;\n  }\n\n  return arcArea + polygonArea;\n}\n\n/**\n * returns whether a point is contained by all of a list of circles\n * @param {{x: number, y: number}} point\n * @param {ReadonlyArray<{x: number, y: number, radius: number}>} circles\n * @returns {boolean}\n */\nfunction containedInCircles(point, circles) {\n  return circles.every((circle) => distance(point, circle) < circle.radius + SMALL);\n}\n\n/**\n * Gets all intersection points between a bunch of circles\n * @param {ReadonlyArray<{x: number, y: number, radius: number}>} circles\n * @returns {ReadonlyArray<{x: number, y: number, parentIndex: [number, number]}>}\n */\nfunction getIntersectionPoints(circles) {\n  /** @type {{x: number, y: number, parentIndex: [number, number]}[]} */\n  const ret = [];\n  for (let i = 0; i < circles.length; ++i) {\n    for (let j = i + 1; j < circles.length; ++j) {\n      const intersect = circleCircleIntersection(circles[i], circles[j]);\n      for (const p of intersect) {\n        p.parentIndex = [i, j];\n        ret.push(p);\n      }\n    }\n  }\n  return ret;\n}\n\n/**\n * Circular segment area calculation. See http://mathworld.wolfram.com/CircularSegment.html\n * @param {number} r\n * @param {number} width\n * @returns {number}\n **/\nfunction circleArea(r, width) {\n  return r * r * Math.acos(1 - width / r) - (r - width) * Math.sqrt(width * (2 * r - width));\n}\n\n/**\n * euclidean distance between two points\n * @param {{x: number, y: number}} p1\n * @param {{x: number, y: number}} p2\n * @returns {number}\n **/\nfunction distance(p1, p2) {\n  return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n}\n\n/**\n * Returns the overlap area of two circles of radius r1 and r2 - that\n * have their centers separated by distance d. Simpler faster\n * circle intersection for only two circles\n * @param {number} r1\n * @param {number} r2\n * @param {number} d\n * @returns {number}\n */\nfunction circleOverlap(r1, r2, d) {\n  // no overlap\n  if (d >= r1 + r2) {\n    return 0;\n  }\n\n  // completely overlapped\n  if (d <= Math.abs(r1 - r2)) {\n    return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);\n  }\n\n  const w1 = r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d);\n  const w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d);\n  return circleArea(r1, w1) + circleArea(r2, w2);\n}\n\n/**\n * Given two circles (containing a x/y/radius attributes),\n * returns the intersecting points if possible\n * note: doesn't handle cases where there are infinitely many\n * intersection points (circles are equivalent):, or only one intersection point\n * @param {{x: number, y: number, radius: number}} p1\n * @param {{x: number, y: number, radius: number}} p2\n * @returns {ReadonlyArray<{x: number, y: number}>}\n **/\nfunction circleCircleIntersection(p1, p2) {\n  const d = distance(p1, p2);\n  const r1 = p1.radius;\n  const r2 = p2.radius;\n\n  // if to far away, or self contained - can't be done\n  if (d >= r1 + r2 || d <= Math.abs(r1 - r2)) {\n    return [];\n  }\n\n  const a = (r1 * r1 - r2 * r2 + d * d) / (2 * d);\n  const h = Math.sqrt(r1 * r1 - a * a);\n  const x0 = p1.x + (a * (p2.x - p1.x)) / d;\n  const y0 = p1.y + (a * (p2.y - p1.y)) / d;\n  const rx = -(p2.y - p1.y) * (h / d);\n  const ry = -(p2.x - p1.x) * (h / d);\n\n  return [\n    { x: x0 + rx, y: y0 - ry },\n    { x: x0 - rx, y: y0 + ry },\n  ];\n}\n\n/**\n * Returns the center of a bunch of points\n * @param {ReadonlyArray<{x: number, y: number}>} points\n * @returns {{x: number, y: number}}\n */\nfunction getCenter(points) {\n  const center = { x: 0, y: 0 };\n  for (const point of points) {\n    center.x += point.x;\n    center.y += point.y;\n  }\n  center.x /= points.length;\n  center.y /= points.length;\n  return center;\n}\n\n/**\n * given a list of set objects, and their corresponding overlaps\n * updates the (x, y, radius) attribute on each set such that their positions\n * roughly correspond to the desired overlaps\n * @param {readonly {sets: readonly string[]; size: number; weight?: number}[]} sets\n * @returns {{[setid: string]: {x: number, y: number, radius: number}}}\n */\nfunction venn(sets, parameters = {}) {\n  parameters.maxIterations = parameters.maxIterations || 500;\n\n  const initialLayout = parameters.initialLayout || bestInitialLayout;\n  const loss = parameters.lossFunction || lossFunction;\n\n  // add in missing pairwise areas as having 0 size\n  const areas = addMissingAreas(sets, parameters);\n\n  // initial layout is done greedily\n  const circles = initialLayout(areas, parameters);\n\n  // transform x/y coordinates to a vector to optimize\n  const setids = Object.keys(circles);\n  /** @type {number[]} */\n  const initial = [];\n  for (const setid of setids) {\n    initial.push(circles[setid].x);\n    initial.push(circles[setid].y);\n  }\n\n  // optimize initial layout from our loss function\n  const solution = nelderMead(\n    (values) => {\n      const current = {};\n      for (let i = 0; i < setids.length; ++i) {\n        const setid = setids[i];\n        current[setid] = {\n          x: values[2 * i],\n          y: values[2 * i + 1],\n          radius: circles[setid].radius,\n          // size : circles[setid].size\n        };\n      }\n      return loss(current, areas);\n    },\n    initial,\n    parameters\n  );\n\n  // transform solution vector back to x/y points\n  const positions = solution.x;\n  for (let i = 0; i < setids.length; ++i) {\n    const setid = setids[i];\n    circles[setid].x = positions[2 * i];\n    circles[setid].y = positions[2 * i + 1];\n  }\n\n  return circles;\n}\n\nconst SMALL$1 = 1e-10;\n\n/**\n * Returns the distance necessary for two circles of radius r1 + r2 to\n * have the overlap area 'overlap'\n * @param {number} r1\n * @param {number} r2\n * @param {number} overlap\n * @returns {number}\n */\nfunction distanceFromIntersectArea(r1, r2, overlap) {\n  // handle complete overlapped circles\n  if (Math.min(r1, r2) * Math.min(r1, r2) * Math.PI <= overlap + SMALL$1) {\n    return Math.abs(r1 - r2);\n  }\n\n  return bisect((distance) => circleOverlap(r1, r2, distance) - overlap, 0, r1 + r2);\n}\n\n/**\n * Missing pair-wise intersection area data can cause problems:\n * treating as an unknown means that sets will be laid out overlapping,\n * which isn't what people expect. To reflect that we want disjoint sets\n * here, set the overlap to 0 for all missing pairwise set intersections\n * @param {ReadonlyArray<{sets: ReadonlyArray<string>, size: number}>} areas\n * @returns {ReadonlyArray<{sets: ReadonlyArray<string>, size: number}>}\n */\nfunction addMissingAreas(areas, parameters = {}) {\n  const distinct = parameters.distinct;\n  const r = areas.map((s) => Object.assign({}, s));\n\n  function toKey(arr) {\n    return arr.join(';');\n  }\n\n  if (distinct) {\n    // recreate the full ones by adding things up but just to level two since the rest doesn't matter\n    /** @types Map<string, number> */\n    const count = new Map();\n    for (const area of r) {\n      for (let i = 0; i < area.sets.length; i++) {\n        const si = String(area.sets[i]);\n        count.set(si, area.size + (count.get(si) || 0));\n        for (let j = i + 1; j < area.sets.length; j++) {\n          const sj = String(area.sets[j]);\n          const k1 = `${si};${sj}`;\n          const k2 = `${sj};${si}`;\n          count.set(k1, area.size + (count.get(k1) || 0));\n          count.set(k2, area.size + (count.get(k2) || 0));\n        }\n      }\n    }\n    for (const area of r) {\n      if (area.sets.length < 3) {\n        area.size = count.get(toKey(area.sets));\n      }\n    }\n  }\n\n  // two circle intersections that aren't defined\n  const ids = [];\n\n  /** @type {Set<string>} */\n  const pairs = new Set();\n  for (const area of r) {\n    if (area.sets.length === 1) {\n      ids.push(area.sets[0]);\n    } else if (area.sets.length === 2) {\n      const a = area.sets[0];\n      const b = area.sets[1];\n      pairs.add(toKey(area.sets));\n      pairs.add(toKey([b, a]));\n    }\n  }\n\n  ids.sort((a, b) => (a === b ? 0 : a < b ? -1 : +1));\n\n  for (let i = 0; i < ids.length; ++i) {\n    const a = ids[i];\n    for (let j = i + 1; j < ids.length; ++j) {\n      const b = ids[j];\n      if (!pairs.has(toKey([a, b]))) {\n        r.push({ sets: [a, b], size: 0 });\n      }\n    }\n  }\n  return r;\n}\n\n/**\n * Returns two matrices, one of the euclidean distances between the sets\n * and the other indicating if there are subset or disjoint set relationships\n * @param {ReadonlyArray<{sets: ReadonlyArray<number>}>} areas\n * @param {ReadonlyArray<{size: number}>} sets\n * @param {ReadonlyArray<number>} setids\n */\nfunction getDistanceMatrices(areas, sets, setids) {\n  // initialize an empty distance matrix between all the points\n  /**\n   * @type {number[][]}\n   */\n  const distances = zerosM(sets.length, sets.length);\n  /**\n   * @type {number[][]}\n   */\n  const constraints = zerosM(sets.length, sets.length);\n\n  // compute required distances between all the sets such that\n  // the areas match\n  areas\n    .filter((x) => x.sets.length === 2)\n    .forEach((current) => {\n      const left = setids[current.sets[0]];\n      const right = setids[current.sets[1]];\n      const r1 = Math.sqrt(sets[left].size / Math.PI);\n      const r2 = Math.sqrt(sets[right].size / Math.PI);\n      const distance = distanceFromIntersectArea(r1, r2, current.size);\n\n      distances[left][right] = distances[right][left] = distance;\n\n      // also update constraints to indicate if its a subset or disjoint\n      // relationship\n      let c = 0;\n      if (current.size + 1e-10 >= Math.min(sets[left].size, sets[right].size)) {\n        c = 1;\n      } else if (current.size <= 1e-10) {\n        c = -1;\n      }\n      constraints[left][right] = constraints[right][left] = c;\n    });\n\n  return { distances, constraints };\n}\n\n/// computes the gradient and loss simultaneously for our constrained MDS optimizer\nfunction constrainedMDSGradient(x, fxprime, distances, constraints) {\n  for (let i = 0; i < fxprime.length; ++i) {\n    fxprime[i] = 0;\n  }\n\n  let loss = 0;\n  for (let i = 0; i < distances.length; ++i) {\n    const xi = x[2 * i];\n    const yi = x[2 * i + 1];\n    for (let j = i + 1; j < distances.length; ++j) {\n      const xj = x[2 * j];\n      const yj = x[2 * j + 1];\n      const dij = distances[i][j];\n      const constraint = constraints[i][j];\n\n      const squaredDistance = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi);\n      const distance = Math.sqrt(squaredDistance);\n      const delta = squaredDistance - dij * dij;\n\n      if ((constraint > 0 && distance <= dij) || (constraint < 0 && distance >= dij)) {\n        continue;\n      }\n\n      loss += 2 * delta * delta;\n\n      fxprime[2 * i] += 4 * delta * (xi - xj);\n      fxprime[2 * i + 1] += 4 * delta * (yi - yj);\n\n      fxprime[2 * j] += 4 * delta * (xj - xi);\n      fxprime[2 * j + 1] += 4 * delta * (yj - yi);\n    }\n  }\n  return loss;\n}\n\n/**\n * takes the best working variant of either constrained MDS or greedy\n * @param {ReadonlyArray<{sets: ReadonlyArray<string>, size: number}>} areas\n */\nfunction bestInitialLayout(areas, params = {}) {\n  let initial = greedyLayout(areas, params);\n  const loss = params.lossFunction || lossFunction;\n\n  // greedylayout is sufficient for all 2/3 circle cases. try out\n  // constrained MDS for higher order problems, take its output\n  // if it outperforms. (greedy is aesthetically better on 2/3 circles\n  // since it axis aligns)\n  if (areas.length >= 8) {\n    const constrained = constrainedMDSLayout(areas, params);\n    const constrainedLoss = loss(constrained, areas);\n    const greedyLoss = loss(initial, areas);\n\n    if (constrainedLoss + 1e-8 < greedyLoss) {\n      initial = constrained;\n    }\n  }\n  return initial;\n}\n\n/**\n * use the constrained MDS variant to generate an initial layout\n * @param {ReadonlyArray<{sets: ReadonlyArray<string>, size: number}>} areas\n * @returns {{[key: string]: {x: number, y: number, radius: number}}}\n */\nfunction constrainedMDSLayout(areas, params = {}) {\n  const restarts = params.restarts || 10;\n\n  // bidirectionally map sets to a rowid  (so we can create a matrix)\n  const sets = [];\n  const setids = {};\n  for (const area of areas) {\n    if (area.sets.length === 1) {\n      setids[area.sets[0]] = sets.length;\n      sets.push(area);\n    }\n  }\n\n  let { distances, constraints } = getDistanceMatrices(areas, sets, setids);\n\n  // keep distances bounded, things get messed up otherwise.\n  // TODO: proper preconditioner?\n  const norm = norm2(distances.map(norm2)) / distances.length;\n  distances = distances.map((row) => row.map((value) => value / norm));\n\n  const obj = (x, fxprime) => constrainedMDSGradient(x, fxprime, distances, constraints);\n\n  let best = null;\n  for (let i = 0; i < restarts; ++i) {\n    const initial = zeros(distances.length * 2).map(Math.random);\n\n    const current = conjugateGradient(obj, initial, params);\n    if (!best || current.fx < best.fx) {\n      best = current;\n    }\n  }\n\n  const positions = best.x;\n\n  // translate rows back to (x,y,radius) coordinates\n  /** @type {{[key: string]: {x: number, y: number, radius: number}}} */\n  const circles = {};\n  for (let i = 0; i < sets.length; ++i) {\n    const set = sets[i];\n    circles[set.sets[0]] = {\n      x: positions[2 * i] * norm,\n      y: positions[2 * i + 1] * norm,\n      radius: Math.sqrt(set.size / Math.PI),\n    };\n  }\n\n  if (params.history) {\n    for (const h of params.history) {\n      scale(h.x, norm);\n    }\n  }\n  return circles;\n}\n\n/**\n * Lays out a Venn diagram greedily, going from most overlapped sets to\n * least overlapped, attempting to position each new set such that the\n * overlapping areas to already positioned sets are basically right\n * @param {ReadonlyArray<{size: number, sets: ReadonlyArray<string>}>} areas\n * @return {{[key: string]: {x: number, y: number, radius: number}}}\n */\nfunction greedyLayout(areas, params) {\n  const loss = params && params.lossFunction ? params.lossFunction : lossFunction;\n\n  // define a circle for each set\n  /** @type {{[key: string]: {x: number, y: number, radius: number}}} */\n  const circles = {};\n  /** @type {{[key: string]: {set: string, size: number, weight: number}[]}} */\n  const setOverlaps = {};\n  for (const area of areas) {\n    if (area.sets.length === 1) {\n      const set = area.sets[0];\n      circles[set] = {\n        x: 1e10,\n        y: 1e10,\n        rowid: circles.length,\n        size: area.size,\n        radius: Math.sqrt(area.size / Math.PI),\n      };\n      setOverlaps[set] = [];\n    }\n  }\n\n  areas = areas.filter((a) => a.sets.length === 2);\n\n  // map each set to a list of all the other sets that overlap it\n  for (const current of areas) {\n    let weight = current.weight != null ? current.weight : 1.0;\n    const left = current.sets[0];\n    const right = current.sets[1];\n\n    // completely overlapped circles shouldn't be positioned early here\n    if (current.size + SMALL$1 >= Math.min(circles[left].size, circles[right].size)) {\n      weight = 0;\n    }\n\n    setOverlaps[left].push({ set: right, size: current.size, weight });\n    setOverlaps[right].push({ set: left, size: current.size, weight });\n  }\n\n  // get list of most overlapped sets\n  const mostOverlapped = [];\n  Object.keys(setOverlaps).forEach((set) => {\n    let size = 0;\n    for (let i = 0; i < setOverlaps[set].length; ++i) {\n      size += setOverlaps[set][i].size * setOverlaps[set][i].weight;\n    }\n\n    mostOverlapped.push({ set, size });\n  });\n\n  // sort by size desc\n  function sortOrder(a, b) {\n    return b.size - a.size;\n  }\n  mostOverlapped.sort(sortOrder);\n\n  // keep track of what sets have been laid out\n  const positioned = {};\n  function isPositioned(element) {\n    return element.set in positioned;\n  }\n\n  /**\n   * adds a point to the output\n   * @param {{x: number, y: number}} point\n   * @param {number} index\n   */\n  function positionSet(point, index) {\n    circles[index].x = point.x;\n    circles[index].y = point.y;\n    positioned[index] = true;\n  }\n\n  // add most overlapped set at (0,0)\n  positionSet({ x: 0, y: 0 }, mostOverlapped[0].set);\n\n  // get distances between all points. TODO, necessary?\n  // answer: probably not\n  // var distances = venn.getDistanceMatrices(circles, areas).distances;\n  for (let i = 1; i < mostOverlapped.length; ++i) {\n    const setIndex = mostOverlapped[i].set;\n    const overlap = setOverlaps[setIndex].filter(isPositioned);\n    const set = circles[setIndex];\n    overlap.sort(sortOrder);\n\n    if (overlap.length === 0) {\n      // this shouldn't happen anymore with addMissingAreas\n      throw 'ERROR: missing pairwise overlap information';\n    }\n\n    /** @type {{x: number, y: number}[]} */\n    const points = [];\n    for (var j = 0; j < overlap.length; ++j) {\n      // get appropriate distance from most overlapped already added set\n      const p1 = circles[overlap[j].set];\n      const d1 = distanceFromIntersectArea(set.radius, p1.radius, overlap[j].size);\n\n      // sample positions at 90 degrees for maximum aesthetics\n      points.push({ x: p1.x + d1, y: p1.y });\n      points.push({ x: p1.x - d1, y: p1.y });\n      points.push({ y: p1.y + d1, x: p1.x });\n      points.push({ y: p1.y - d1, x: p1.x });\n\n      // if we have at least 2 overlaps, then figure out where the\n      // set should be positioned analytically and try those too\n      for (let k = j + 1; k < overlap.length; ++k) {\n        const p2 = circles[overlap[k].set];\n        const d2 = distanceFromIntersectArea(set.radius, p2.radius, overlap[k].size);\n\n        const extraPoints = circleCircleIntersection(\n          { x: p1.x, y: p1.y, radius: d1 },\n          { x: p2.x, y: p2.y, radius: d2 }\n        );\n        points.push(...extraPoints);\n      }\n    }\n\n    // we have some candidate positions for the set, examine loss\n    // at each position to figure out where to put it at\n    let bestLoss = 1e50;\n    let bestPoint = points[0];\n    for (const point of points) {\n      circles[setIndex].x = point.x;\n      circles[setIndex].y = point.y;\n      const localLoss = loss(circles, areas);\n      if (localLoss < bestLoss) {\n        bestLoss = localLoss;\n        bestPoint = point;\n      }\n    }\n\n    positionSet(bestPoint, setIndex);\n  }\n\n  return circles;\n}\n\n/**\n * Given a bunch of sets, and the desired overlaps between these sets - computes\n * the distance from the actual overlaps to the desired overlaps. Note that\n * this method ignores overlaps of more than 2 circles\n * @param {{[key: string]: <{x: number, y: number, radius: number}>}} circles\n * @param {ReadonlyArray<{size: number, sets: ReadonlyArray<string>, weight?: number}>} overlaps\n * @returns {number}\n */\nfunction lossFunction(circles, overlaps) {\n  let output = 0;\n\n  for (const area of overlaps) {\n    if (area.sets.length === 1) {\n      continue;\n    }\n    /** @type {number} */\n    let overlap;\n    if (area.sets.length === 2) {\n      const left = circles[area.sets[0]];\n      const right = circles[area.sets[1]];\n      overlap = circleOverlap(left.radius, right.radius, distance(left, right));\n    } else {\n      overlap = intersectionArea(area.sets.map((d) => circles[d]));\n    }\n\n    const weight = area.weight != null ? area.weight : 1.0;\n    output += weight * (overlap - area.size) * (overlap - area.size);\n  }\n\n  return output;\n}\n\nfunction logRatioLossFunction(circles, overlaps) {\n  let output = 0;\n\n  for (const area of overlaps) {\n    if (area.sets.length === 1) {\n      continue;\n    }\n    /** @type {number} */\n    let overlap;\n    if (area.sets.length === 2) {\n      const left = circles[area.sets[0]];\n      const right = circles[area.sets[1]];\n      overlap = circleOverlap(left.radius, right.radius, distance(left, right));\n    } else {\n      overlap = intersectionArea(area.sets.map((d) => circles[d]));\n    }\n\n    const weight = area.weight != null ? area.weight : 1.0;\n    const differenceFromIdeal = Math.log((overlap + 1) / (area.size + 1));\n    output += weight * differenceFromIdeal * differenceFromIdeal;\n  }\n\n  return output;\n}\n\n/**\n * orientates a bunch of circles to point in orientation\n * @param {{x :number, y: number, radius: number}[]} circles\n * @param {number | undefined} orientation\n * @param {((a: {x :number, y: number, radius: number}, b: {x :number, y: number, radius: number}) => number) | undefined} orientationOrder\n */\nfunction orientateCircles(circles, orientation, orientationOrder) {\n  if (orientationOrder == null) {\n    circles.sort((a, b) => b.radius - a.radius);\n  } else {\n    circles.sort(orientationOrder);\n  }\n\n  // shift circles so largest circle is at (0, 0)\n  if (circles.length > 0) {\n    const largestX = circles[0].x;\n    const largestY = circles[0].y;\n\n    for (const circle of circles) {\n      circle.x -= largestX;\n      circle.y -= largestY;\n    }\n  }\n\n  if (circles.length === 2) {\n    // if the second circle is a subset of the first, arrange so that\n    // it is off to one side. hack for https://github.com/benfred/venn.js/issues/120\n    const dist = distance(circles[0], circles[1]);\n    if (dist < Math.abs(circles[1].radius - circles[0].radius)) {\n      circles[1].x = circles[0].x + circles[0].radius - circles[1].radius - 1e-10;\n      circles[1].y = circles[0].y;\n    }\n  }\n\n  // rotate circles so that second largest is at an angle of 'orientation'\n  // from largest\n  if (circles.length > 1) {\n    const rotation = Math.atan2(circles[1].x, circles[1].y) - orientation;\n    const c = Math.cos(rotation);\n    const s = Math.sin(rotation);\n\n    for (const circle of circles) {\n      const x = circle.x;\n      const y = circle.y;\n      circle.x = c * x - s * y;\n      circle.y = s * x + c * y;\n    }\n  }\n\n  // mirror solution if third solution is above plane specified by\n  // first two circles\n  if (circles.length > 2) {\n    let angle = Math.atan2(circles[2].x, circles[2].y) - orientation;\n    while (angle < 0) {\n      angle += 2 * Math.PI;\n    }\n    while (angle > 2 * Math.PI) {\n      angle -= 2 * Math.PI;\n    }\n    if (angle > Math.PI) {\n      const slope = circles[1].y / (1e-10 + circles[1].x);\n      for (const circle of circles) {\n        var d = (circle.x + slope * circle.y) / (1 + slope * slope);\n        circle.x = 2 * d - circle.x;\n        circle.y = 2 * d * slope - circle.y;\n      }\n    }\n  }\n}\n\n/**\n *\n * @param {ReadonlyArray<{x: number, y: number, radius: number}>} circles\n * @returns {{x: number, y: number, radius: number}[][]}\n */\nfunction disjointCluster(circles) {\n  // union-find clustering to get disjoint sets\n  circles.forEach((circle) => {\n    circle.parent = circle;\n  });\n\n  // path compression step in union find\n  function find(circle) {\n    if (circle.parent !== circle) {\n      circle.parent = find(circle.parent);\n    }\n    return circle.parent;\n  }\n\n  function union(x, y) {\n    const xRoot = find(x);\n    const yRoot = find(y);\n    xRoot.parent = yRoot;\n  }\n\n  // get the union of all overlapping sets\n  for (let i = 0; i < circles.length; ++i) {\n    for (let j = i + 1; j < circles.length; ++j) {\n      const maxDistance = circles[i].radius + circles[j].radius;\n      if (distance(circles[i], circles[j]) + 1e-10 < maxDistance) {\n        union(circles[j], circles[i]);\n      }\n    }\n  }\n\n  // find all the disjoint clusters and group them together\n  /** @type {Map<string, {x: number, y: number, radius: number}[]>} */\n  const disjointClusters = new Map();\n  for (let i = 0; i < circles.length; ++i) {\n    const setid = find(circles[i]).parent.setid;\n    if (!disjointClusters.has(setid)) {\n      disjointClusters.set(setid, []);\n    }\n    disjointClusters.get(setid).push(circles[i]);\n  }\n\n  // cleanup bookkeeping\n  circles.forEach((circle) => {\n    delete circle.parent;\n  });\n\n  // return in more usable form\n  return Array.from(disjointClusters.values());\n}\n\n/**\n * @param {ReadonlyArray<{x :number, y: number, radius: number}>} circles\n * @returns {{xRange: [number, number], yRange: [number, number]}}\n */\nfunction getBoundingBox(circles) {\n  const minMax = (d) => {\n    const hi = circles.reduce((acc, c) => Math.max(acc, c[d] + c.radius), Number.NEGATIVE_INFINITY);\n    const lo = circles.reduce((acc, c) => Math.min(acc, c[d] - c.radius), Number.POSITIVE_INFINITY);\n    return { max: hi, min: lo };\n  };\n  return { xRange: minMax('x'), yRange: minMax('y') };\n}\n\n/**\n *\n * @param {{[setid: string]: {x: number, y: number, radius: number}}} solution\n * @param {undefined | number} orientation\n * @param {((a: {x :number, y: number, radius: number}, b: {x :number, y: number, radius: number}) => number) | undefined} orientationOrder\n * @returns {{[setid: string]: {x: number, y: number, radius: number}}}\n */\nfunction normalizeSolution(solution, orientation, orientationOrder) {\n  if (orientation == null) {\n    orientation = Math.PI / 2;\n  }\n\n  // work with a list instead of a dictionary, and take a copy so we\n  // don't mutate input\n  let circles = fromObjectNotation(solution).map((d) => Object.assign({}, d));\n\n  // get all the disjoint clusters\n  const clusters = disjointCluster(circles);\n\n  // orientate all disjoint sets, get sizes\n  for (const cluster of clusters) {\n    orientateCircles(cluster, orientation, orientationOrder);\n    const bounds = getBoundingBox(cluster);\n    cluster.size = (bounds.xRange.max - bounds.xRange.min) * (bounds.yRange.max - bounds.yRange.min);\n    cluster.bounds = bounds;\n  }\n  clusters.sort((a, b) => b.size - a.size);\n\n  // orientate the largest at 0,0, and get the bounds\n  circles = clusters[0];\n  let returnBounds = circles.bounds;\n  const spacing = (returnBounds.xRange.max - returnBounds.xRange.min) / 50;\n\n  /**\n   * @param {ReadonlyArray<{x: number, y: number, radius: number, setid: string}>} cluster\n   * @param {boolean} right\n   * @param {boolean} bottom\n   */\n  function addCluster(cluster, right, bottom) {\n    if (!cluster) {\n      return;\n    }\n\n    const bounds = cluster.bounds;\n    /** @type {number} */\n    let xOffset;\n    /** @type {number} */\n    let yOffset;\n\n    if (right) {\n      xOffset = returnBounds.xRange.max - bounds.xRange.min + spacing;\n    } else {\n      xOffset = returnBounds.xRange.max - bounds.xRange.max;\n      const centreing =\n        (bounds.xRange.max - bounds.xRange.min) / 2 - (returnBounds.xRange.max - returnBounds.xRange.min) / 2;\n      if (centreing < 0) {\n        xOffset += centreing;\n      }\n    }\n\n    if (bottom) {\n      yOffset = returnBounds.yRange.max - bounds.yRange.min + spacing;\n    } else {\n      yOffset = returnBounds.yRange.max - bounds.yRange.max;\n      const centreing =\n        (bounds.yRange.max - bounds.yRange.min) / 2 - (returnBounds.yRange.max - returnBounds.yRange.min) / 2;\n      if (centreing < 0) {\n        yOffset += centreing;\n      }\n    }\n\n    for (const c of cluster) {\n      c.x += xOffset;\n      c.y += yOffset;\n      circles.push(c);\n    }\n  }\n\n  let index = 1;\n  while (index < clusters.length) {\n    addCluster(clusters[index], true, false);\n    addCluster(clusters[index + 1], false, true);\n    addCluster(clusters[index + 2], true, true);\n    index += 3;\n\n    // have one cluster (in top left). lay out next three relative\n    // to it in a grid\n    returnBounds = getBoundingBox(circles);\n  }\n\n  // convert back to solution form\n  return toObjectNotation(circles);\n}\n\n/**\n * Scales a solution from venn.venn or venn.greedyLayout such that it fits in\n * a rectangle of width/height - with padding around the borders. also\n * centers the diagram in the available space at the same time.\n * If the scale parameter is not null, this automatic scaling is ignored in favor of this custom one\n * @param {{[setid: string]: {x: number, y: number, radius: number}}} solution\n * @param {number} width\n * @param {number} height\n * @param {number} padding\n * @param {boolean} scaleToFit\n * @returns {{[setid: string]: {x: number, y: number, radius: number}}}\n */\nfunction scaleSolution(solution, width, height, padding, scaleToFit) {\n  const circles = fromObjectNotation(solution);\n\n  width -= 2 * padding;\n  height -= 2 * padding;\n\n  const { xRange, yRange } = getBoundingBox(circles);\n\n  if (xRange.max === xRange.min || yRange.max === yRange.min) {\n    console.log('not scaling solution: zero size detected');\n    return solution;\n  }\n\n  /** @type {number} */\n  let xScaling;\n  /** @type {number} */\n  let yScaling;\n  if (scaleToFit) {\n    const toScaleDiameter = Math.sqrt(scaleToFit / Math.PI) * 2;\n    xScaling = width / toScaleDiameter;\n    yScaling = height / toScaleDiameter;\n  } else {\n    xScaling = width / (xRange.max - xRange.min);\n    yScaling = height / (yRange.max - yRange.min);\n  }\n\n  const scaling = Math.min(yScaling, xScaling);\n  // while we're at it, center the diagram too\n  const xOffset = (width - (xRange.max - xRange.min) * scaling) / 2;\n  const yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;\n\n  return toObjectNotation(\n    circles.map((circle) => ({\n      radius: scaling * circle.radius,\n      x: padding + xOffset + (circle.x - xRange.min) * scaling,\n      y: padding + yOffset + (circle.y - yRange.min) * scaling,\n      setid: circle.setid,\n    }))\n  );\n}\n\n/**\n * @param {readonly {x: number, y: number, radius: number, setid: string}[]} circles\n * @returns {{[setid: string]: {x: number, y: number, radius: number}}}\n */\nfunction toObjectNotation(circles) {\n  /** @type {{[setid: string]: {x: number, y: number, radius: number}}} */\n  const r = {};\n  for (const circle of circles) {\n    r[circle.setid] = circle;\n  }\n  return r;\n}\n/**\n * @param {{[setid: string]: {x: number, y: number, radius: number}}} solution\n * @returns {{x: number, y: number, radius: number, setid: string}[]}}\n */\nfunction fromObjectNotation(solution) {\n  const setids = Object.keys(solution);\n  return setids.map((id) => Object.assign(solution[id], { setid: id }));\n}\n\n/*global console:true*/\n\n/**\n * VennDiagram includes an optional `options` parameter containing the following option(s):\n *\n * `colourScheme: Array<String>`\n * A list of color values to be applied when coloring diagram circles.\n *\n * `symmetricalTextCentre: Boolean`\n * Whether to symmetrically center each circle's text horizontally and vertically.\n * Defaults to `false`.\n *\n * `textFill: String`\n * The color to be applied to the text within each circle.\n *\n * @param {object} options\n */\nfunction VennDiagram(options = {}) {\n  let useViewBox = false,\n    width = 600,\n    height = 350,\n    padding = 15,\n    duration = 1000,\n    orientation = Math.PI / 2,\n    normalize = true,\n    scaleToFit = null,\n    wrap = true,\n    styled = true,\n    fontSize = null,\n    orientationOrder = null,\n    distinct = false,\n    round = null,\n    symmetricalTextCentre = options && options.symmetricalTextCentre ? options.symmetricalTextCentre : false,\n    // mimic the behaviour of d3.scale.category10 from the previous\n    // version of d3\n    colourMap = {},\n    // so this is the same as d3.schemeCategory10, which is only defined in d3 4.0\n    // since we can support older versions of d3 as long as we don't force this,\n    // I'm hackily redefining below. TODO: remove this and change to d3.schemeCategory10\n    colourScheme =\n      options && options.colourScheme\n        ? options.colourScheme\n        : options && options.colorScheme\n        ? options.colorScheme\n        : [\n            '#1f77b4',\n            '#ff7f0e',\n            '#2ca02c',\n            '#d62728',\n            '#9467bd',\n            '#8c564b',\n            '#e377c2',\n            '#7f7f7f',\n            '#bcbd22',\n            '#17becf',\n          ],\n    colourIndex = 0,\n    colours = function (key) {\n      if (key in colourMap) {\n        return colourMap[key];\n      }\n      var ret = (colourMap[key] = colourScheme[colourIndex]);\n      colourIndex += 1;\n      if (colourIndex >= colourScheme.length) {\n        colourIndex = 0;\n      }\n      return ret;\n    },\n    layoutFunction = venn,\n    loss = lossFunction;\n\n  function chart(selection) {\n    let data = selection.datum();\n\n    // handle 0-sized sets by removing from input\n    const toRemove = new Set();\n    data.forEach((datum) => {\n      if (datum.size == 0 && datum.sets.length == 1) {\n        toRemove.add(datum.sets[0]);\n      }\n    });\n    data = data.filter((datum) => !datum.sets.some((set) => toRemove.has(set)));\n\n    let circles = {};\n    let textCentres = {};\n\n    if (data.length > 0) {\n      let solution = layoutFunction(data, { lossFunction: loss, distinct });\n\n      if (normalize) {\n        solution = normalizeSolution(solution, orientation, orientationOrder);\n      }\n\n      circles = scaleSolution(solution, width, height, padding, scaleToFit);\n      textCentres = computeTextCentres(circles, data, symmetricalTextCentre);\n    }\n\n    // Figure out the current label for each set. These can change\n    // and D3 won't necessarily update (fixes https://github.com/benfred/venn.js/issues/103)\n    const labels = {};\n    data.forEach((datum) => {\n      if (datum.label) {\n        labels[datum.sets] = datum.label;\n      }\n    });\n\n    function label(d) {\n      if (d.sets in labels) {\n        return labels[d.sets];\n      }\n      if (d.sets.length == 1) {\n        return '' + d.sets[0];\n      }\n    }\n\n    // create svg if not already existing\n    selection.selectAll('svg').data([circles]).enter().append('svg');\n\n    const svg = selection.select('svg');\n\n    if (useViewBox) {\n      svg.attr('viewBox', `0 0 ${width} ${height}`);\n    } else {\n      svg.attr('width', width).attr('height', height);\n    }\n\n    // to properly transition intersection areas, we need the\n    // previous circles locations. load from elements\n    const previous = {};\n    let hasPrevious = false;\n    svg.selectAll('.venn-area path').each(function (d) {\n      const path = this.getAttribute('d');\n      if (d.sets.length == 1 && path && !distinct) {\n        hasPrevious = true;\n        previous[d.sets[0]] = circleFromPath(path);\n      }\n    });\n    // interpolate intersection area paths between previous and\n    // current paths\n    function pathTween(d) {\n      return (t) => {\n        const c = d.sets.map((set) => {\n          let start = previous[set];\n          let end = circles[set];\n          if (!start) {\n            start = { x: width / 2, y: height / 2, radius: 1 };\n          }\n          if (!end) {\n            end = { x: width / 2, y: height / 2, radius: 1 };\n          }\n          return {\n            x: start.x * (1 - t) + end.x * t,\n            y: start.y * (1 - t) + end.y * t,\n            radius: start.radius * (1 - t) + end.radius * t,\n          };\n        });\n        return intersectionAreaPath(c, round);\n      };\n    }\n\n    // update data, joining on the set ids\n    const nodes = svg.selectAll('.venn-area').data(data, (d) => d.sets);\n\n    // create new nodes\n    const enter = nodes\n      .enter()\n      .append('g')\n      .attr(\n        'class',\n        (d) =>\n          `venn-area venn-${d.sets.length == 1 ? 'circle' : 'intersection'}${\n            d.colour || d.color ? ' venn-coloured' : ''\n          }`\n      )\n      .attr('data-venn-sets', (d) => d.sets.join('_'));\n\n    const enterPath = enter.append('path');\n    const enterText = enter\n      .append('text')\n      .attr('class', 'label')\n      .text((d) => label(d))\n      .attr('text-anchor', 'middle')\n      .attr('dy', '.35em')\n      .attr('x', width / 2)\n      .attr('y', height / 2);\n\n    // apply minimal style if wanted\n    if (styled) {\n      enterPath\n        .style('fill-opacity', '0')\n        .filter((d) => d.sets.length == 1)\n        .style('fill', (d) => (d.colour ? d.colour : d.color ? d.color : colours(d.sets)))\n        .style('fill-opacity', '.25');\n\n      enterText.style('fill', (d) => {\n        if (d.colour || d.color) {\n          return '#FFF';\n        }\n        if (options.textFill) {\n          return options.textFill;\n        }\n        return d.sets.length == 1 ? colours(d.sets) : '#444';\n      });\n    }\n\n    function asTransition(s) {\n      if (typeof s.transition === 'function') {\n        return s.transition('venn').duration(duration);\n      }\n      return s;\n    }\n\n    // update existing, using pathTween if necessary\n    let update = selection;\n    if (hasPrevious && typeof update.transition === 'function') {\n      update = asTransition(selection);\n      update.selectAll('path').attrTween('d', pathTween);\n    } else {\n      update.selectAll('path').attr('d', (d) => intersectionAreaPath(d.sets.map((set) => circles[set])), round);\n    }\n\n    const updateText = update\n      .selectAll('text')\n      .filter((d) => d.sets in textCentres)\n      .text((d) => label(d))\n      .attr('x', (d) => Math.floor(textCentres[d.sets].x))\n      .attr('y', (d) => Math.floor(textCentres[d.sets].y));\n\n    if (wrap) {\n      if (hasPrevious) {\n        // d3 4.0 uses 'on' for events on transitions,\n        // but d3 3.0 used 'each' instead. switch appropriately\n        if ('on' in updateText) {\n          updateText.on('end', wrapText(circles, label));\n        } else {\n          updateText.each('end', wrapText(circles, label));\n        }\n      } else {\n        updateText.each(wrapText(circles, label));\n      }\n    }\n\n    // remove old\n    const exit = asTransition(nodes.exit()).remove();\n    if (typeof nodes.transition === 'function') {\n      exit.selectAll('path').attrTween('d', pathTween);\n    }\n\n    const exitText = exit\n      .selectAll('text')\n      .attr('x', width / 2)\n      .attr('y', height / 2);\n\n    // if we've been passed a fontSize explicitly, use it to\n    // transition\n    if (fontSize !== null) {\n      enterText.style('font-size', '0px');\n      updateText.style('font-size', fontSize);\n      exitText.style('font-size', '0px');\n    }\n\n    return { circles, textCentres, nodes, enter, update, exit };\n  }\n\n  chart.wrap = function (_) {\n    if (!arguments.length) return wrap;\n    wrap = _;\n    return chart;\n  };\n\n  chart.useViewBox = function () {\n    useViewBox = true;\n    return chart;\n  };\n\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n\n  chart.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return chart;\n  };\n\n  chart.padding = function (_) {\n    if (!arguments.length) return padding;\n    padding = _;\n    return chart;\n  };\n\n  chart.distinct = function (_) {\n    if (!arguments.length) return distinct;\n    distinct = _;\n    return chart;\n  };\n\n  chart.colours = function (_) {\n    if (!arguments.length) return colours;\n    colours = _;\n    return chart;\n  };\n\n  chart.colors = function (_) {\n    if (!arguments.length) return colors;\n    colours = _;\n    return chart;\n  };\n\n  chart.fontSize = function (_) {\n    if (!arguments.length) return fontSize;\n    fontSize = _;\n    return chart;\n  };\n\n  chart.round = function (_) {\n    if (!arguments.length) return round;\n    round = _;\n    return chart;\n  };\n\n  chart.duration = function (_) {\n    if (!arguments.length) return duration;\n    duration = _;\n    return chart;\n  };\n\n  chart.layoutFunction = function (_) {\n    if (!arguments.length) return layoutFunction;\n    layoutFunction = _;\n    return chart;\n  };\n\n  chart.normalize = function (_) {\n    if (!arguments.length) return normalize;\n    normalize = _;\n    return chart;\n  };\n\n  chart.scaleToFit = function (_) {\n    if (!arguments.length) return scaleToFit;\n    scaleToFit = _;\n    return chart;\n  };\n\n  chart.styled = function (_) {\n    if (!arguments.length) return styled;\n    styled = _;\n    return chart;\n  };\n\n  chart.orientation = function (_) {\n    if (!arguments.length) return orientation;\n    orientation = _;\n    return chart;\n  };\n\n  chart.orientationOrder = function (_) {\n    if (!arguments.length) return orientationOrder;\n    orientationOrder = _;\n    return chart;\n  };\n\n  chart.lossFunction = function (_) {\n    if (!arguments.length) return loss;\n    loss = _ === 'default' ? lossFunction : _ === 'logRatio' ? logRatioLossFunction : _;\n    return chart;\n  };\n\n  return chart;\n}\n\n// sometimes text doesn't fit inside the circle, if thats the case lets wrap\n// the text here such that it fits\n// todo: looks like this might be merged into d3 (\n// https://github.com/mbostock/d3/issues/1642),\n// also worth checking out is\n// http://engineering.findthebest.com/wrapping-axis-labels-in-d3-js/\n// this seems to be one of those things that should be easy but isn't\nfunction wrapText(circles, labeller) {\n  return function (data) {\n    const text = this;\n    const width = circles[data.sets[0]].radius || 50;\n    const label = labeller(data) || '';\n\n    const words = label.split(/\\s+/).reverse();\n    const maxLines = 3;\n    const minChars = (label.length + words.length) / maxLines;\n\n    let word = words.pop();\n    let line = [word];\n    let lineNumber = 0;\n    const lineHeight = 1.1; // ems\n    text.textContent = null; // clear\n    const tspans = [];\n\n    function append(word) {\n      const tspan = text.ownerDocument.createElementNS(text.namespaceURI, 'tspan');\n      tspan.textContent = word;\n      tspans.push(tspan);\n      text.append(tspan);\n      return tspan;\n    }\n    let tspan = append(word);\n\n    while (true) {\n      word = words.pop();\n      if (!word) {\n        break;\n      }\n      line.push(word);\n      const joined = line.join(' ');\n      tspan.textContent = joined;\n      if (joined.length > minChars && tspan.getComputedTextLength() > width) {\n        line.pop();\n        tspan.textContent = line.join(' ');\n        line = [word];\n        tspan = append(word);\n        lineNumber++;\n      }\n    }\n\n    const initial = 0.35 - (lineNumber * lineHeight) / 2;\n    const x = text.getAttribute('x');\n    const y = text.getAttribute('y');\n    tspans.forEach((t, i) => {\n      t.setAttribute('x', x);\n      t.setAttribute('y', y);\n      t.setAttribute('dy', `${initial + i * lineHeight}em`);\n    });\n  };\n}\n\n/**\n *\n * @param {{x: number, y: number}} current\n * @param {ReadonlyArray<{x: number, y: number}>} interior\n * @param {ReadonlyArray<{x: number, y: number}>} exterior\n * @returns {number}\n */\nfunction circleMargin(current, interior, exterior) {\n  let margin = interior[0].radius - distance(interior[0], current);\n\n  for (let i = 1; i < interior.length; ++i) {\n    const m = interior[i].radius - distance(interior[i], current);\n    if (m <= margin) {\n      margin = m;\n    }\n  }\n\n  for (let i = 0; i < exterior.length; ++i) {\n    const m = distance(exterior[i], current) - exterior[i].radius;\n    if (m <= margin) {\n      margin = m;\n    }\n  }\n  return margin;\n}\n\n/**\n * compute the center of some circles by maximizing the margin of\n * the center point relative to the circles (interior) after subtracting\n * nearby circles (exterior)\n * @param {readonly {x: number, y: number, radius: number}[]} interior\n * @param {readonly {x: number, y: number, radius: number}[]} exterior\n * @param {boolean} symmetricalTextCentre\n * @returns {{x:number, y: number}}\n */\nfunction computeTextCentre(interior, exterior, symmetricalTextCentre) {\n  // get an initial estimate by sampling around the interior circles\n  // and taking the point with the biggest margin\n  /** @type {{x: number, y: number}[]} */\n  const points = [];\n  for (const c of interior) {\n    points.push({ x: c.x, y: c.y });\n    points.push({ x: c.x + c.radius / 2, y: c.y });\n    points.push({ x: c.x - c.radius / 2, y: c.y });\n    points.push({ x: c.x, y: c.y + c.radius / 2 });\n    points.push({ x: c.x, y: c.y - c.radius / 2 });\n  }\n\n  let initial = points[0];\n  let margin = circleMargin(points[0], interior, exterior);\n\n  for (let i = 1; i < points.length; ++i) {\n    const m = circleMargin(points[i], interior, exterior);\n    if (m >= margin) {\n      initial = points[i];\n      margin = m;\n    }\n  }\n\n  // maximize the margin numerically\n  const solution = nelderMead(\n    (p) => -1 * circleMargin({ x: p[0], y: p[1] }, interior, exterior),\n    [initial.x, initial.y],\n    { maxIterations: 500, minErrorDelta: 1e-10 }\n  ).x;\n\n  const ret = { x: symmetricalTextCentre ? 0 : solution[0], y: solution[1] };\n\n  // check solution, fallback as needed (happens if fully overlapped\n  // etc)\n  let valid = true;\n  for (const i of interior) {\n    if (distance(ret, i) > i.radius) {\n      valid = false;\n      break;\n    }\n  }\n\n  for (const e of exterior) {\n    if (distance(ret, e) < e.radius) {\n      valid = false;\n      break;\n    }\n  }\n  if (valid) {\n    return ret;\n  }\n\n  if (interior.length == 1) {\n    return { x: interior[0].x, y: interior[0].y };\n  }\n  const areaStats = {};\n  intersectionArea(interior, areaStats);\n\n  if (areaStats.arcs.length === 0) {\n    return { x: 0, y: -1000, disjoint: true };\n  }\n  if (areaStats.arcs.length == 1) {\n    return { x: areaStats.arcs[0].circle.x, y: areaStats.arcs[0].circle.y };\n  }\n  if (exterior.length) {\n    // try again without other circles\n    return computeTextCentre(interior, []);\n  }\n  // take average of all the points in the intersection\n  // polygon. this should basically never happen\n  // and has some issues:\n  // https://github.com/benfred/venn.js/issues/48#issuecomment-146069777\n  return getCenter(areaStats.arcs.map((a) => a.p1));\n}\n\n// given a dictionary of {setid : circle}, returns\n// a dictionary of setid to list of circles that completely overlap it\nfunction getOverlappingCircles(circles) {\n  const ret = {};\n  const circleids = Object.keys(circles);\n  for (const circleid of circleids) {\n    ret[circleid] = [];\n  }\n  for (let i = 0; i < circleids.length; i++) {\n    const ci = circleids[i];\n    const a = circles[ci];\n    for (let j = i + 1; j < circleids.length; ++j) {\n      const cj = circleids[j];\n      const b = circles[cj];\n      const d = distance(a, b);\n\n      if (d + b.radius <= a.radius + 1e-10) {\n        ret[cj].push(ci);\n      } else if (d + a.radius <= b.radius + 1e-10) {\n        ret[ci].push(cj);\n      }\n    }\n  }\n  return ret;\n}\n\nfunction computeTextCentres(circles, areas, symmetricalTextCentre) {\n  const ret = {};\n  const overlapped = getOverlappingCircles(circles);\n  for (let i = 0; i < areas.length; ++i) {\n    const area = areas[i].sets;\n    const areaids = {};\n    const exclude = {};\n\n    for (let j = 0; j < area.length; ++j) {\n      areaids[area[j]] = true;\n      const overlaps = overlapped[area[j]];\n      // keep track of any circles that overlap this area,\n      // and don't consider for purposes of computing the text\n      // centre\n      for (let k = 0; k < overlaps.length; ++k) {\n        exclude[overlaps[k]] = true;\n      }\n    }\n\n    const interior = [];\n    const exterior = [];\n    for (let setid in circles) {\n      if (setid in areaids) {\n        interior.push(circles[setid]);\n      } else if (!(setid in exclude)) {\n        exterior.push(circles[setid]);\n      }\n    }\n    const centre = computeTextCentre(interior, exterior, symmetricalTextCentre);\n    ret[area] = centre;\n    if (centre.disjoint && areas[i].size > 0) {\n      console.log('WARNING: area ' + area + ' not represented on screen');\n    }\n  }\n  return ret;\n}\n\n// sorts all areas in the venn diagram, so that\n// a particular area is on top (relativeTo) - and\n// all other areas are so that the smallest areas are on top\nfunction sortAreas(div, relativeTo) {\n  // figure out sets that are completely overlapped by relativeTo\n  const overlaps = getOverlappingCircles(div.selectAll('svg').datum());\n  const exclude = new Set();\n  for (const check of relativeTo.sets) {\n    for (let setid in overlaps) {\n      const overlap = overlaps[setid];\n      for (let j = 0; j < overlap.length; ++j) {\n        if (overlap[j] == check) {\n          exclude.add(setid);\n          break;\n        }\n      }\n    }\n  }\n\n  // checks that all sets are in exclude;\n  function shouldExclude(sets) {\n    return sets.every((set) => !exclude.has(set));\n  }\n\n  // need to sort div's so that Z order is correct\n  div.selectAll('g').sort((a, b) => {\n    // highest order set intersections first\n    if (a.sets.length != b.sets.length) {\n      return a.sets.length - b.sets.length;\n    }\n\n    if (a == relativeTo) {\n      return shouldExclude(b.sets) ? -1 : 1;\n    }\n    if (b == relativeTo) {\n      return shouldExclude(a.sets) ? 1 : -1;\n    }\n\n    // finally by size\n    return b.size - a.size;\n  });\n}\n\n/**\n * @param {number} x\n * @param {number} y\n * @param {number} r\n * @returns {string}\n */\nfunction circlePath(x, y, r) {\n  const ret = [];\n  ret.push('\\nM', x, y);\n  ret.push('\\nm', -r, 0);\n  ret.push('\\na', r, r, 0, 1, 0, r * 2, 0);\n  ret.push('\\na', r, r, 0, 1, 0, -r * 2, 0);\n  return ret.join(' ');\n}\n\n/**\n * inverse of the circlePath function, returns a circle object from an svg path\n * @param {string} path\n * @returns {{x: number, y: number, radius: number}}\n */\nfunction circleFromPath(path) {\n  const tokens = path.split(' ');\n  return { x: Number.parseFloat(tokens[1]), y: Number.parseFloat(tokens[2]), radius: -Number.parseFloat(tokens[4]) };\n}\n\nfunction intersectionAreaArcs(circles) {\n  if (circles.length === 0) {\n    return [];\n  }\n  const stats = {};\n  intersectionArea(circles, stats);\n  return stats.arcs;\n}\n\nfunction arcsToPath(arcs, round) {\n  if (arcs.length === 0) {\n    return 'M 0 0';\n  }\n  const rFactor = Math.pow(10, round || 0);\n  const r = round != null ? (v) => Math.round(v * rFactor) / rFactor : (v) => v;\n  if (arcs.length == 1) {\n    const circle = arcs[0].circle;\n    return circlePath(r(circle.x), r(circle.y), r(circle.radius));\n  }\n  // draw path around arcs\n  const ret = ['\\nM', r(arcs[0].p2.x), r(arcs[0].p2.y)];\n  for (const arc of arcs) {\n    const radius = r(arc.circle.radius);\n    ret.push('\\nA', radius, radius, 0, arc.large ? 1 : 0, arc.sweep ? 1 : 0, r(arc.p1.x), r(arc.p1.y));\n  }\n  return ret.join(' ');\n}\n\n/**\n * returns a svg path of the intersection area of a bunch of circles\n * @param {ReadonlyArray<{x: number, y: number, radius: number}>} circles\n * @returns {string}\n */\nfunction intersectionAreaPath(circles, round) {\n  return arcsToPath(intersectionAreaArcs(circles), round);\n}\n\nfunction layout(data, options = {}) {\n  const {\n    lossFunction: loss,\n    layoutFunction: layout = venn,\n    normalize = true,\n    orientation = Math.PI / 2,\n    orientationOrder,\n    width = 600,\n    height = 350,\n    padding = 15,\n    scaleToFit = false,\n    symmetricalTextCentre = false,\n    distinct,\n    round = 2,\n  } = options;\n\n  let solution = layout(data, {\n    lossFunction: loss === 'default' || !loss ? lossFunction : loss === 'logRatio' ? logRatioLossFunction : loss,\n    distinct,\n  });\n\n  if (normalize) {\n    solution = normalizeSolution(solution, orientation, orientationOrder);\n  }\n\n  const circles = scaleSolution(solution, width, height, padding, scaleToFit);\n  const textCentres = computeTextCentres(circles, data, symmetricalTextCentre);\n\n  const circleLookup = new Map(\n    Object.keys(circles).map((set) => [\n      set,\n      {\n        set,\n        x: circles[set].x,\n        y: circles[set].y,\n        radius: circles[set].radius,\n      },\n    ])\n  );\n  const helpers = data.map((area) => {\n    const circles = area.sets.map((s) => circleLookup.get(s));\n    const arcs = intersectionAreaArcs(circles);\n    const path = arcsToPath(arcs, round);\n    return { circles, arcs, path, area, has: new Set(area.sets) };\n  });\n\n  function genDistinctPath(sets) {\n    let r = '';\n    for (const e of helpers) {\n      if (e.has.size > sets.length && sets.every((s) => e.has.has(s))) {\n        r += ' ' + e.path;\n      }\n    }\n    return r;\n  }\n\n  return helpers.map(({ circles, arcs, path, area }) => {\n    return {\n      data: area,\n      text: textCentres[area.sets],\n      circles,\n      arcs,\n      path,\n      distinctPath: path + genDistinctPath(area.sets),\n    };\n  });\n}\n\nexport { VennDiagram, bestInitialLayout, circleArea, circleCircleIntersection, circleFromPath, circleOverlap, circlePath, computeTextCentre, computeTextCentres, disjointCluster, distance, distanceFromIntersectArea, greedyLayout, intersectionArea, intersectionAreaPath, layout, logRatioLossFunction, lossFunction, normalizeSolution, scaleSolution, sortAreas, venn, wrapText };\n"]},"metadata":{},"sourceType":"module"}