{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nvar React = require('react');\n\nvar ReactDOM = require('react-dom');\n\nvar PropTypes = require('prop-types');\n\nvar _require = require('focus-trap'),\n    createFocusTrap = _require.createFocusTrap; // TODO: These issues are related to older React features which we'll likely need\n//  to fix in order to move the code forward to the next major version of React.\n//  @see https://github.com/davidtheclark/focus-trap-react/issues/77\n\n/* eslint-disable react/no-find-dom-node */\n\n\nvar FocusTrap = /*#__PURE__*/function (_React$Component) {\n  _inherits(FocusTrap, _React$Component);\n\n  var _super = _createSuper(FocusTrap);\n\n  function FocusTrap(props) {\n    var _this;\n\n    _classCallCheck(this, FocusTrap);\n\n    _this = _super.call(this, props); // We need to hijack the returnFocusOnDeactivate option,\n    // because React can move focus into the element before we arrived at\n    // this lifecycle hook (e.g. with autoFocus inputs). So the component\n    // captures the previouslyFocusedElement in componentWillMount,\n    // then (optionally) returns focus to it in componentWillUnmount.\n\n    _this.tailoredFocusTrapOptions = {\n      returnFocusOnDeactivate: false\n    }; // because of the above, we maintain our own flag for this option, and\n    //  default it to `true` because that's focus-trap's default\n\n    _this.returnFocusOnDeactivate = true;\n    var focusTrapOptions = props.focusTrapOptions;\n\n    for (var optionName in focusTrapOptions) {\n      if (!Object.prototype.hasOwnProperty.call(focusTrapOptions, optionName)) {\n        continue;\n      }\n\n      if (optionName === 'returnFocusOnDeactivate') {\n        _this.returnFocusOnDeactivate = !!focusTrapOptions[optionName];\n        continue;\n      }\n\n      if (optionName === 'onPostDeactivate') {\n        _this.onPostDeactivate = focusTrapOptions[optionName];\n        continue;\n      }\n\n      _this.tailoredFocusTrapOptions[optionName] = focusTrapOptions[optionName];\n    } // elements from which to create the focus trap on mount; if a child is used\n    //  instead of the `containerElements` prop, we'll get the child's related\n    //  element when the trap renders and then is declared 'mounted'\n\n\n    _this.focusTrapElements = props.containerElements || []; // now we remember what the currently focused element is, not relying on focus-trap\n\n    _this.updatePreviousElement();\n\n    return _this;\n  } // TODO: Need more test coverage for this function\n\n\n  _createClass(FocusTrap, [{\n    key: \"getNodeForOption\",\n    value: function getNodeForOption(optionName) {\n      var optionValue = this.tailoredFocusTrapOptions[optionName];\n\n      if (!optionValue) {\n        return null;\n      }\n\n      var node = optionValue;\n\n      if (typeof optionValue === 'string') {\n        node = document.querySelector(optionValue);\n\n        if (!node) {\n          throw new Error(\"`\".concat(optionName, \"` refers to no known node\"));\n        }\n      }\n\n      if (typeof optionValue === 'function') {\n        node = optionValue();\n\n        if (!node) {\n          throw new Error(\"`\".concat(optionName, \"` did not return a node\"));\n        }\n      }\n\n      return node;\n    }\n  }, {\n    key: \"getReturnFocusNode\",\n    value: function getReturnFocusNode() {\n      var node = this.getNodeForOption('setReturnFocus');\n      return node ? node : this.previouslyFocusedElement;\n    }\n    /** Update the previously focused element with the currently focused element. */\n\n  }, {\n    key: \"updatePreviousElement\",\n    value: function updatePreviousElement() {\n      // SSR: careful to check if `document` exists before accessing it as a variable\n      var currentDocument = this.props.focusTrapOptions.document || (typeof document !== 'undefined' ? document : undefined);\n\n      if (currentDocument) {\n        this.previouslyFocusedElement = currentDocument.activeElement;\n      }\n    }\n  }, {\n    key: \"deactivateTrap\",\n    value: function deactivateTrap() {\n      var _this2 = this;\n\n      var _this$tailoredFocusTr = this.tailoredFocusTrapOptions,\n          checkCanReturnFocus = _this$tailoredFocusTr.checkCanReturnFocus,\n          _this$tailoredFocusTr2 = _this$tailoredFocusTr.preventScroll,\n          preventScroll = _this$tailoredFocusTr2 === void 0 ? false : _this$tailoredFocusTr2;\n\n      if (this.focusTrap) {\n        // NOTE: we never let the trap return the focus since we do that ourselves\n        this.focusTrap.deactivate({\n          returnFocus: false\n        });\n      }\n\n      var finishDeactivation = function finishDeactivation() {\n        var returnFocusNode = _this2.getReturnFocusNode();\n\n        var canReturnFocus = (returnFocusNode === null || returnFocusNode === void 0 ? void 0 : returnFocusNode.focus) && _this2.returnFocusOnDeactivate;\n\n        if (canReturnFocus) {\n          /** Returns focus to the element that had focus when the trap was activated. */\n          returnFocusNode.focus({\n            preventScroll: preventScroll\n          });\n        }\n\n        if (_this2.onPostDeactivate) {\n          _this2.onPostDeactivate.call(null); // don't call it in context of \"this\"\n\n        }\n      };\n\n      if (checkCanReturnFocus) {\n        checkCanReturnFocus(this.getReturnFocusNode()).then(finishDeactivation, finishDeactivation);\n      } else {\n        finishDeactivation();\n      }\n    }\n  }, {\n    key: \"setupFocusTrap\",\n    value: function setupFocusTrap() {\n      if (!this.focusTrap) {\n        var focusTrapElementDOMNodes = this.focusTrapElements.map( // NOTE: `findDOMNode()` does not support CSS selectors; it'll just return\n        //  a new text node with the text wrapped in it instead of treating the\n        //  string as a selector and resolving it to a node in the DOM\n        ReactDOM.findDOMNode);\n        var nodesExist = focusTrapElementDOMNodes.some(Boolean);\n\n        if (nodesExist) {\n          // eslint-disable-next-line react/prop-types -- _createFocusTrap is an internal prop\n          this.focusTrap = this.props._createFocusTrap(focusTrapElementDOMNodes, this.tailoredFocusTrapOptions);\n\n          if (this.props.active) {\n            this.focusTrap.activate();\n          }\n\n          if (this.props.paused) {\n            this.focusTrap.pause();\n          }\n        }\n      }\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.setupFocusTrap();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (this.focusTrap) {\n        if (prevProps.containerElements !== this.props.containerElements) {\n          this.focusTrap.updateContainerElements(this.props.containerElements);\n        }\n\n        var hasActivated = !prevProps.active && this.props.active;\n        var hasDeactivated = prevProps.active && !this.props.active;\n        var hasPaused = !prevProps.paused && this.props.paused;\n        var hasUnpaused = prevProps.paused && !this.props.paused;\n\n        if (hasActivated) {\n          this.updatePreviousElement();\n          this.focusTrap.activate();\n        }\n\n        if (hasDeactivated) {\n          this.deactivateTrap();\n          return; // un/pause does nothing on an inactive trap\n        }\n\n        if (hasPaused) {\n          this.focusTrap.pause();\n        }\n\n        if (hasUnpaused) {\n          this.focusTrap.unpause();\n        }\n      } else if (prevProps.containerElements !== this.props.containerElements) {\n        this.focusTrapElements = this.props.containerElements;\n        this.setupFocusTrap();\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.deactivateTrap();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      var child = this.props.children ? React.Children.only(this.props.children) : undefined;\n\n      if (child) {\n        if (child.type && child.type === React.Fragment) {\n          throw new Error('A focus-trap cannot use a Fragment as its child container. Try replacing it with a <div> element.');\n        }\n\n        var composedRefCallback = function composedRefCallback(element) {\n          var containerElements = _this3.props.containerElements;\n\n          if (child) {\n            if (typeof child.ref === 'function') {\n              child.ref(element);\n            } else if (child.ref) {\n              child.ref.current = element;\n            }\n          }\n\n          _this3.focusTrapElements = containerElements ? containerElements : [element];\n        };\n\n        var childWithRef = React.cloneElement(child, {\n          ref: composedRefCallback\n        });\n        return childWithRef;\n      }\n\n      return null;\n    }\n  }]);\n\n  return FocusTrap;\n}(React.Component); // support server-side rendering where `Element` will not be defined\n\n\nvar ElementType = typeof Element === 'undefined' ? Function : Element;\nFocusTrap.propTypes = {\n  active: PropTypes.bool,\n  paused: PropTypes.bool,\n  focusTrapOptions: PropTypes.shape({\n    document: PropTypes.object,\n    onActivate: PropTypes.func,\n    onPostActivate: PropTypes.func,\n    checkCanFocusTrap: PropTypes.func,\n    onDeactivate: PropTypes.func,\n    onPostDeactivate: PropTypes.func,\n    checkCanReturnFocus: PropTypes.func,\n    initialFocus: PropTypes.oneOfType([PropTypes.instanceOf(ElementType), PropTypes.string, PropTypes.func, PropTypes.bool]),\n    fallbackFocus: PropTypes.oneOfType([PropTypes.instanceOf(ElementType), PropTypes.string, PropTypes.func]),\n    escapeDeactivates: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n    clickOutsideDeactivates: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n    returnFocusOnDeactivate: PropTypes.bool,\n    setReturnFocus: PropTypes.oneOfType([PropTypes.instanceOf(ElementType), PropTypes.string, PropTypes.func]),\n    allowOutsideClick: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n    preventScroll: PropTypes.bool\n  }),\n  containerElements: PropTypes.arrayOf(PropTypes.instanceOf(ElementType)),\n  children: PropTypes.oneOfType([PropTypes.element, // React element\n  PropTypes.instanceOf(ElementType) // DOM element\n  ]) // NOTE: _createFocusTrap is internal, for testing purposes only, so we don't\n  //  specify it here. It's expected to be set to the function returned from\n  //  require('focus-trap'), or one with a compatible interface.\n\n};\nFocusTrap.defaultProps = {\n  active: true,\n  paused: false,\n  focusTrapOptions: {},\n  _createFocusTrap: createFocusTrap\n};\nmodule.exports = FocusTrap;","map":{"version":3,"sources":["/Users/xuehui/Desktop/NUS_Stuff/AY2122.1_Y4S1/Capstone/lta-visualization/frontend/node_modules/focus-trap-react/dist/focus-trap-react.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","_inherits","subClass","superClass","create","value","_setPrototypeOf","o","p","setPrototypeOf","__proto__","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","_getPrototypeOf","result","NewTarget","Reflect","construct","arguments","apply","_possibleConstructorReturn","self","call","_assertThisInitialized","ReferenceError","sham","Proxy","Boolean","valueOf","e","getPrototypeOf","React","require","ReactDOM","PropTypes","_require","createFocusTrap","FocusTrap","_React$Component","_super","_this","tailoredFocusTrapOptions","returnFocusOnDeactivate","focusTrapOptions","optionName","hasOwnProperty","onPostDeactivate","focusTrapElements","containerElements","updatePreviousElement","getNodeForOption","optionValue","node","document","querySelector","Error","concat","getReturnFocusNode","previouslyFocusedElement","currentDocument","undefined","activeElement","deactivateTrap","_this2","_this$tailoredFocusTr","checkCanReturnFocus","_this$tailoredFocusTr2","preventScroll","focusTrap","deactivate","returnFocus","finishDeactivation","returnFocusNode","canReturnFocus","focus","then","setupFocusTrap","focusTrapElementDOMNodes","map","findDOMNode","nodesExist","some","_createFocusTrap","active","activate","paused","pause","componentDidMount","componentDidUpdate","prevProps","updateContainerElements","hasActivated","hasDeactivated","hasPaused","hasUnpaused","unpause","componentWillUnmount","render","_this3","child","children","Children","only","type","Fragment","composedRefCallback","element","ref","current","childWithRef","cloneElement","Component","ElementType","Element","Function","propTypes","bool","shape","object","onActivate","func","onPostActivate","checkCanFocusTrap","onDeactivate","initialFocus","oneOfType","instanceOf","string","fallbackFocus","escapeDeactivates","clickOutsideDeactivates","setReturnFocus","allowOutsideClick","arrayOf","defaultProps","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar React = require('react');\n\nvar ReactDOM = require('react-dom');\n\nvar PropTypes = require('prop-types');\n\nvar _require = require('focus-trap'),\n    createFocusTrap = _require.createFocusTrap; // TODO: These issues are related to older React features which we'll likely need\n//  to fix in order to move the code forward to the next major version of React.\n//  @see https://github.com/davidtheclark/focus-trap-react/issues/77\n\n/* eslint-disable react/no-find-dom-node */\n\n\nvar FocusTrap = /*#__PURE__*/function (_React$Component) {\n  _inherits(FocusTrap, _React$Component);\n\n  var _super = _createSuper(FocusTrap);\n\n  function FocusTrap(props) {\n    var _this;\n\n    _classCallCheck(this, FocusTrap);\n\n    _this = _super.call(this, props); // We need to hijack the returnFocusOnDeactivate option,\n    // because React can move focus into the element before we arrived at\n    // this lifecycle hook (e.g. with autoFocus inputs). So the component\n    // captures the previouslyFocusedElement in componentWillMount,\n    // then (optionally) returns focus to it in componentWillUnmount.\n\n    _this.tailoredFocusTrapOptions = {\n      returnFocusOnDeactivate: false\n    }; // because of the above, we maintain our own flag for this option, and\n    //  default it to `true` because that's focus-trap's default\n\n    _this.returnFocusOnDeactivate = true;\n    var focusTrapOptions = props.focusTrapOptions;\n\n    for (var optionName in focusTrapOptions) {\n      if (!Object.prototype.hasOwnProperty.call(focusTrapOptions, optionName)) {\n        continue;\n      }\n\n      if (optionName === 'returnFocusOnDeactivate') {\n        _this.returnFocusOnDeactivate = !!focusTrapOptions[optionName];\n        continue;\n      }\n\n      if (optionName === 'onPostDeactivate') {\n        _this.onPostDeactivate = focusTrapOptions[optionName];\n        continue;\n      }\n\n      _this.tailoredFocusTrapOptions[optionName] = focusTrapOptions[optionName];\n    } // elements from which to create the focus trap on mount; if a child is used\n    //  instead of the `containerElements` prop, we'll get the child's related\n    //  element when the trap renders and then is declared 'mounted'\n\n\n    _this.focusTrapElements = props.containerElements || []; // now we remember what the currently focused element is, not relying on focus-trap\n\n    _this.updatePreviousElement();\n\n    return _this;\n  } // TODO: Need more test coverage for this function\n\n\n  _createClass(FocusTrap, [{\n    key: \"getNodeForOption\",\n    value: function getNodeForOption(optionName) {\n      var optionValue = this.tailoredFocusTrapOptions[optionName];\n\n      if (!optionValue) {\n        return null;\n      }\n\n      var node = optionValue;\n\n      if (typeof optionValue === 'string') {\n        node = document.querySelector(optionValue);\n\n        if (!node) {\n          throw new Error(\"`\".concat(optionName, \"` refers to no known node\"));\n        }\n      }\n\n      if (typeof optionValue === 'function') {\n        node = optionValue();\n\n        if (!node) {\n          throw new Error(\"`\".concat(optionName, \"` did not return a node\"));\n        }\n      }\n\n      return node;\n    }\n  }, {\n    key: \"getReturnFocusNode\",\n    value: function getReturnFocusNode() {\n      var node = this.getNodeForOption('setReturnFocus');\n      return node ? node : this.previouslyFocusedElement;\n    }\n    /** Update the previously focused element with the currently focused element. */\n\n  }, {\n    key: \"updatePreviousElement\",\n    value: function updatePreviousElement() {\n      // SSR: careful to check if `document` exists before accessing it as a variable\n      var currentDocument = this.props.focusTrapOptions.document || (typeof document !== 'undefined' ? document : undefined);\n\n      if (currentDocument) {\n        this.previouslyFocusedElement = currentDocument.activeElement;\n      }\n    }\n  }, {\n    key: \"deactivateTrap\",\n    value: function deactivateTrap() {\n      var _this2 = this;\n\n      var _this$tailoredFocusTr = this.tailoredFocusTrapOptions,\n          checkCanReturnFocus = _this$tailoredFocusTr.checkCanReturnFocus,\n          _this$tailoredFocusTr2 = _this$tailoredFocusTr.preventScroll,\n          preventScroll = _this$tailoredFocusTr2 === void 0 ? false : _this$tailoredFocusTr2;\n\n      if (this.focusTrap) {\n        // NOTE: we never let the trap return the focus since we do that ourselves\n        this.focusTrap.deactivate({\n          returnFocus: false\n        });\n      }\n\n      var finishDeactivation = function finishDeactivation() {\n        var returnFocusNode = _this2.getReturnFocusNode();\n\n        var canReturnFocus = (returnFocusNode === null || returnFocusNode === void 0 ? void 0 : returnFocusNode.focus) && _this2.returnFocusOnDeactivate;\n\n        if (canReturnFocus) {\n          /** Returns focus to the element that had focus when the trap was activated. */\n          returnFocusNode.focus({\n            preventScroll: preventScroll\n          });\n        }\n\n        if (_this2.onPostDeactivate) {\n          _this2.onPostDeactivate.call(null); // don't call it in context of \"this\"\n\n        }\n      };\n\n      if (checkCanReturnFocus) {\n        checkCanReturnFocus(this.getReturnFocusNode()).then(finishDeactivation, finishDeactivation);\n      } else {\n        finishDeactivation();\n      }\n    }\n  }, {\n    key: \"setupFocusTrap\",\n    value: function setupFocusTrap() {\n      if (!this.focusTrap) {\n        var focusTrapElementDOMNodes = this.focusTrapElements.map( // NOTE: `findDOMNode()` does not support CSS selectors; it'll just return\n        //  a new text node with the text wrapped in it instead of treating the\n        //  string as a selector and resolving it to a node in the DOM\n        ReactDOM.findDOMNode);\n        var nodesExist = focusTrapElementDOMNodes.some(Boolean);\n\n        if (nodesExist) {\n          // eslint-disable-next-line react/prop-types -- _createFocusTrap is an internal prop\n          this.focusTrap = this.props._createFocusTrap(focusTrapElementDOMNodes, this.tailoredFocusTrapOptions);\n\n          if (this.props.active) {\n            this.focusTrap.activate();\n          }\n\n          if (this.props.paused) {\n            this.focusTrap.pause();\n          }\n        }\n      }\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.setupFocusTrap();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (this.focusTrap) {\n        if (prevProps.containerElements !== this.props.containerElements) {\n          this.focusTrap.updateContainerElements(this.props.containerElements);\n        }\n\n        var hasActivated = !prevProps.active && this.props.active;\n        var hasDeactivated = prevProps.active && !this.props.active;\n        var hasPaused = !prevProps.paused && this.props.paused;\n        var hasUnpaused = prevProps.paused && !this.props.paused;\n\n        if (hasActivated) {\n          this.updatePreviousElement();\n          this.focusTrap.activate();\n        }\n\n        if (hasDeactivated) {\n          this.deactivateTrap();\n          return; // un/pause does nothing on an inactive trap\n        }\n\n        if (hasPaused) {\n          this.focusTrap.pause();\n        }\n\n        if (hasUnpaused) {\n          this.focusTrap.unpause();\n        }\n      } else if (prevProps.containerElements !== this.props.containerElements) {\n        this.focusTrapElements = this.props.containerElements;\n        this.setupFocusTrap();\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.deactivateTrap();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      var child = this.props.children ? React.Children.only(this.props.children) : undefined;\n\n      if (child) {\n        if (child.type && child.type === React.Fragment) {\n          throw new Error('A focus-trap cannot use a Fragment as its child container. Try replacing it with a <div> element.');\n        }\n\n        var composedRefCallback = function composedRefCallback(element) {\n          var containerElements = _this3.props.containerElements;\n\n          if (child) {\n            if (typeof child.ref === 'function') {\n              child.ref(element);\n            } else if (child.ref) {\n              child.ref.current = element;\n            }\n          }\n\n          _this3.focusTrapElements = containerElements ? containerElements : [element];\n        };\n\n        var childWithRef = React.cloneElement(child, {\n          ref: composedRefCallback\n        });\n        return childWithRef;\n      }\n\n      return null;\n    }\n  }]);\n\n  return FocusTrap;\n}(React.Component); // support server-side rendering where `Element` will not be defined\n\n\nvar ElementType = typeof Element === 'undefined' ? Function : Element;\nFocusTrap.propTypes = {\n  active: PropTypes.bool,\n  paused: PropTypes.bool,\n  focusTrapOptions: PropTypes.shape({\n    document: PropTypes.object,\n    onActivate: PropTypes.func,\n    onPostActivate: PropTypes.func,\n    checkCanFocusTrap: PropTypes.func,\n    onDeactivate: PropTypes.func,\n    onPostDeactivate: PropTypes.func,\n    checkCanReturnFocus: PropTypes.func,\n    initialFocus: PropTypes.oneOfType([PropTypes.instanceOf(ElementType), PropTypes.string, PropTypes.func, PropTypes.bool]),\n    fallbackFocus: PropTypes.oneOfType([PropTypes.instanceOf(ElementType), PropTypes.string, PropTypes.func]),\n    escapeDeactivates: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n    clickOutsideDeactivates: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n    returnFocusOnDeactivate: PropTypes.bool,\n    setReturnFocus: PropTypes.oneOfType([PropTypes.instanceOf(ElementType), PropTypes.string, PropTypes.func]),\n    allowOutsideClick: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n    preventScroll: PropTypes.bool\n  }),\n  containerElements: PropTypes.arrayOf(PropTypes.instanceOf(ElementType)),\n  children: PropTypes.oneOfType([PropTypes.element, // React element\n  PropTypes.instanceOf(ElementType) // DOM element\n  ]) // NOTE: _createFocusTrap is internal, for testing purposes only, so we don't\n  //  specify it here. It's expected to be set to the function returned from\n  //  require('focus-trap'), or one with a compatible interface.\n\n};\nFocusTrap.defaultProps = {\n  active: true,\n  paused: false,\n  focusTrapOptions: {},\n  _createFocusTrap: createFocusTrap\n};\nmodule.exports = FocusTrap;"]},"metadata":{},"sourceType":"script"}