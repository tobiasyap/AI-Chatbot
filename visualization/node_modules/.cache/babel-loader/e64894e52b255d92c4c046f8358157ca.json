{"ast":null,"code":"// UMD: https://github.com/umdjs/umd/blob/master/returnExports.js\n(function (root, factory) {\n  /* global define: false */\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.humanFormat = factory();\n  }\n})(this, function () {\n  'use strict'; // =================================================================\n\n  function assign(dst, src) {\n    var i, n, prop;\n\n    for (i = 1, n = arguments.length; i < n; ++i) {\n      src = arguments[i];\n\n      if (src != null) {\n        for (prop in src) {\n          if (has(src, prop)) {\n            dst[prop] = src[prop];\n          }\n        }\n      }\n    }\n\n    return dst;\n  }\n\n  function compareLongestFirst(a, b) {\n    return b.length - a.length;\n  }\n\n  function compareSmallestFactorFirst(a, b) {\n    return a.factor - b.factor;\n  } // https://www.npmjs.org/package/escape-regexp\n\n\n  function escapeRegexp(str) {\n    return str.replace(/([.*+?=^!:${}()|[\\]/\\\\])/g, '\\\\$1');\n  }\n\n  function forEach(arr, iterator) {\n    var i, n;\n\n    for (i = 0, n = arr.length; i < n; ++i) {\n      iterator(arr[i], i);\n    }\n  }\n\n  function forOwn(obj, iterator) {\n    var prop;\n\n    for (prop in obj) {\n      if (has(obj, prop)) {\n        iterator(obj[prop], prop);\n      }\n    }\n  }\n\n  var has = function (hasOwnProperty) {\n    return function has(obj, prop) {\n      return obj != null && hasOwnProperty.call(obj, prop);\n    };\n  }(Object.prototype.hasOwnProperty);\n\n  function resolve(container, entry) {\n    while (typeof entry === 'string') {\n      entry = container[entry];\n    }\n\n    return entry;\n  } // =================================================================\n\n\n  function Scale(prefixes) {\n    this._prefixes = prefixes;\n    var escapedPrefixes = [];\n    var list = [];\n    forOwn(prefixes, function (factor, prefix) {\n      escapedPrefixes.push(escapeRegexp(prefix));\n      list.push({\n        factor: factor,\n        prefix: prefix\n      });\n    }); // Adds lower cased prefixes for case insensitive fallback.\n\n    var lcPrefixes = this._lcPrefixes = {};\n    forOwn(prefixes, function (factor, prefix) {\n      var lcPrefix = prefix.toLowerCase();\n\n      if (!has(prefixes, lcPrefix)) {\n        lcPrefixes[lcPrefix] = prefix;\n      }\n    });\n    list.sort(compareSmallestFactorFirst);\n    this._list = list;\n    escapedPrefixes.sort(compareLongestFirst);\n    this._regexp = new RegExp('^\\\\s*(-)?\\\\s*(\\\\d+(?:\\\\.\\\\d+)?)\\\\s*(' + escapedPrefixes.join('|') + ')\\\\s*(.*)\\\\s*?$', 'i');\n  }\n\n  Scale.create = function Scale$create(prefixesList, base, initExp) {\n    var prefixes = {};\n\n    if (initExp === undefined) {\n      initExp = 0;\n    }\n\n    forEach(prefixesList, function (prefix, i) {\n      prefixes[prefix] = Math.pow(base, i + initExp);\n    });\n    return new Scale(prefixes);\n  }; // Binary search to find the greatest index which has a value <=.\n\n\n  Scale.prototype.findPrefix = function Scale$findPrefix(value) {\n    var list = this._list;\n    var low = 0;\n    var high = list.length - 1;\n    var mid, current;\n\n    while (low !== high) {\n      mid = low + high + 1 >> 1;\n      current = list[mid].factor;\n\n      if (current > value) {\n        high = mid - 1;\n      } else {\n        low = mid;\n      }\n    }\n\n    return list[low];\n  };\n\n  Scale.prototype.parse = function Scale$parse(str, strict) {\n    var matches = str.match(this._regexp);\n\n    if (matches === null) {\n      return;\n    }\n\n    var prefix = matches[3];\n    var factor;\n\n    if (has(this._prefixes, prefix)) {\n      factor = this._prefixes[prefix];\n    } else if (!strict && (prefix = prefix.toLowerCase(), has(this._lcPrefixes, prefix))) {\n      prefix = this._lcPrefixes[prefix];\n      factor = this._prefixes[prefix];\n    } else {\n      return;\n    }\n\n    var value = +matches[2];\n\n    if (matches[1] !== undefined) {\n      value = -value;\n    }\n\n    return {\n      factor: factor,\n      prefix: prefix,\n      unit: matches[4],\n      value: value\n    };\n  }; // =================================================================\n\n\n  var scales = {\n    // https://en.wikipedia.org/wiki/Binary_prefix\n    binary: Scale.create(',Ki,Mi,Gi,Ti,Pi,Ei,Zi,Yi'.split(','), 1024),\n    // https://en.wikipedia.org/wiki/Metric_prefix\n    //\n    // Not all prefixes are present, only those which are multiple of\n    // 1000, because humans usually prefer to see close numbers using\n    // the same unit to ease the comparison.\n    SI: Scale.create('y,z,a,f,p,n,µ,m,,k,M,G,T,P,E,Z,Y'.split(','), 1000, -8)\n  };\n  var defaults = {\n    // Decimal digits for formatting.\n    decimals: 2,\n    // separator to use between value and units\n    separator: ' ',\n    // Unit to use for formatting.\n    unit: ''\n  };\n  var rawDefaults = {\n    scale: 'SI',\n    // Strict mode prevents parsing of incorrectly cased prefixes.\n    strict: false\n  };\n\n  function humanFormat(value, opts) {\n    opts = assign({}, defaults, opts);\n    var info = humanFormat$raw(value, opts);\n    value = String(info.value);\n    var suffix = info.prefix + opts.unit;\n    return suffix === '' ? value : value + opts.separator + suffix;\n  }\n\n  var humanFormat$bytes$opts = {\n    scale: 'binary',\n    unit: 'B'\n  };\n\n  function humanFormat$bytes(value, opts) {\n    return humanFormat(value, opts === undefined ? humanFormat$bytes$opts : assign({}, humanFormat$bytes$opts, opts));\n  }\n\n  function humanFormat$parse(str, opts) {\n    var info = humanFormat$parse$raw(str, opts);\n    return info.value * info.factor;\n  }\n\n  function humanFormat$parse$raw(str, opts) {\n    if (typeof str !== 'string') {\n      throw new TypeError('str must be a string');\n    } // Merge default options.\n\n\n    opts = assign({}, rawDefaults, opts); // Get current scale.\n\n    var scale = resolve(scales, opts.scale);\n\n    if (scale === undefined) {\n      throw new Error('missing scale');\n    } // TODO: the unit should be checked: it might be absent but it\n    // should not differ from the one expected.\n    //\n    // TODO: if multiple units are specified, at least must match and\n    // the returned value should be: { value: <value>, unit: matchedUnit }\n\n\n    var info = scale.parse(str, opts.strict);\n\n    if (info === undefined) {\n      throw new Error('cannot parse str');\n    }\n\n    return info;\n  }\n\n  function humanFormat$raw(value, opts) {\n    // Zero is a special case, it never has any prefix.\n    if (value === 0) {\n      return {\n        value: 0,\n        prefix: ''\n      };\n    } else if (value < 0) {\n      var result = humanFormat$raw(-value, opts);\n      result.value = -result.value;\n      return result;\n    }\n\n    if (typeof value !== 'number' || Number.isNaN(value)) {\n      throw new TypeError('value must be a number');\n    } // Merge default options.\n\n\n    opts = assign({}, rawDefaults, opts); // Get current scale.\n\n    var scale = resolve(scales, opts.scale);\n\n    if (scale === undefined) {\n      throw new Error('missing scale');\n    }\n\n    var power;\n    var decimals = opts.decimals;\n\n    if (decimals !== undefined) {\n      power = Math.pow(10, decimals);\n    }\n\n    var prefix = opts.prefix;\n    var factor;\n\n    if (prefix !== undefined) {\n      if (!has(scale._prefixes, prefix)) {\n        throw new Error('invalid prefix');\n      }\n\n      factor = scale._prefixes[prefix];\n    } else {\n      var _ref = scale.findPrefix(value);\n\n      if (power !== undefined) {\n        do {\n          factor = _ref.factor; // factor is usually >> power, therefore it's better to\n          // divide factor by power than the other way to limit\n          // numerical error\n\n          var r = factor / power;\n          value = Math.round(value / r) * r;\n        } while ((_ref = scale.findPrefix(value)).factor !== factor);\n      } else {\n        factor = _ref.factor;\n      }\n\n      prefix = _ref.prefix;\n    }\n\n    return {\n      prefix: prefix,\n      value: power === undefined ? value / factor : Math.round(value * power / factor) / power\n    };\n  }\n\n  humanFormat.bytes = humanFormat$bytes;\n  humanFormat.parse = humanFormat$parse;\n  humanFormat$parse.raw = humanFormat$parse$raw;\n  humanFormat.raw = humanFormat$raw;\n  humanFormat.Scale = Scale;\n  return humanFormat;\n});","map":{"version":3,"sources":["/Users/xuehui/Desktop/NUS_Stuff/AY2122.1_Y4S1/Capstone/lta-visualization/frontend/node_modules/human-format/index.js"],"names":["root","factory","define","amd","exports","module","humanFormat","assign","dst","src","i","n","prop","arguments","length","has","compareLongestFirst","a","b","compareSmallestFactorFirst","factor","escapeRegexp","str","replace","forEach","arr","iterator","forOwn","obj","hasOwnProperty","call","Object","prototype","resolve","container","entry","Scale","prefixes","_prefixes","escapedPrefixes","list","prefix","push","lcPrefixes","_lcPrefixes","lcPrefix","toLowerCase","sort","_list","_regexp","RegExp","join","create","Scale$create","prefixesList","base","initExp","undefined","Math","pow","findPrefix","Scale$findPrefix","value","low","high","mid","current","parse","Scale$parse","strict","matches","match","unit","scales","binary","split","SI","defaults","decimals","separator","rawDefaults","scale","opts","info","humanFormat$raw","String","suffix","humanFormat$bytes$opts","humanFormat$bytes","humanFormat$parse","humanFormat$parse$raw","TypeError","Error","result","Number","isNaN","power","_ref","r","round","bytes","raw"],"mappings":"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","sourcesContent":["// UMD: https://github.com/umdjs/umd/blob/master/returnExports.js\n(function (root, factory) {\n  /* global define: false */\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory)\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory()\n  } else {\n    // Browser globals (root is window)\n    root.humanFormat = factory()\n  }\n}(this, function () {\n  'use strict'\n\n  // =================================================================\n\n  function assign (dst, src) {\n    var i, n, prop\n    for (i = 1, n = arguments.length; i < n; ++i) {\n      src = arguments[i]\n      if (src != null) {\n        for (prop in src) {\n          if (has(src, prop)) {\n            dst[prop] = src[prop]\n          }\n        }\n      }\n    }\n    return dst\n  }\n\n  function compareLongestFirst (a, b) {\n    return b.length - a.length\n  }\n\n  function compareSmallestFactorFirst (a, b) {\n    return a.factor - b.factor\n  }\n\n  // https://www.npmjs.org/package/escape-regexp\n  function escapeRegexp (str) {\n    return str.replace(/([.*+?=^!:${}()|[\\]/\\\\])/g, '\\\\$1')\n  }\n\n  function forEach (arr, iterator) {\n    var i, n\n    for (i = 0, n = arr.length; i < n; ++i) {\n      iterator(arr[i], i)\n    }\n  }\n\n  function forOwn (obj, iterator) {\n    var prop\n    for (prop in obj) {\n      if (has(obj, prop)) {\n        iterator(obj[prop], prop)\n      }\n    }\n  }\n\n  var has = (function (hasOwnProperty) {\n    return function has (obj, prop) {\n      return obj != null && hasOwnProperty.call(obj, prop)\n    }\n  })(Object.prototype.hasOwnProperty)\n\n  function resolve (container, entry) {\n    while (typeof entry === 'string') {\n      entry = container[entry]\n    }\n    return entry\n  }\n\n  // =================================================================\n\n  function Scale (prefixes) {\n    this._prefixes = prefixes\n\n    var escapedPrefixes = []\n    var list = []\n    forOwn(prefixes, function (factor, prefix) {\n      escapedPrefixes.push(escapeRegexp(prefix))\n\n      list.push({\n        factor: factor,\n        prefix: prefix\n      })\n    })\n\n    // Adds lower cased prefixes for case insensitive fallback.\n    var lcPrefixes = this._lcPrefixes = {}\n    forOwn(prefixes, function (factor, prefix) {\n      var lcPrefix = prefix.toLowerCase()\n      if (!has(prefixes, lcPrefix)) {\n        lcPrefixes[lcPrefix] = prefix\n      }\n    })\n\n    list.sort(compareSmallestFactorFirst)\n    this._list = list\n\n    escapedPrefixes.sort(compareLongestFirst)\n    this._regexp = new RegExp(\n      '^\\\\s*(-)?\\\\s*(\\\\d+(?:\\\\.\\\\d+)?)\\\\s*(' +\n      escapedPrefixes.join('|') +\n      ')\\\\s*(.*)\\\\s*?$',\n      'i'\n    )\n  }\n\n  Scale.create = function Scale$create (prefixesList, base, initExp) {\n    var prefixes = {}\n    if (initExp === undefined) {\n      initExp = 0\n    }\n    forEach(prefixesList, function (prefix, i) {\n      prefixes[prefix] = Math.pow(base, i + initExp)\n    })\n\n    return new Scale(prefixes)\n  }\n\n  // Binary search to find the greatest index which has a value <=.\n  Scale.prototype.findPrefix = function Scale$findPrefix (value) {\n    var list = this._list\n    var low = 0\n    var high = list.length - 1\n\n    var mid, current\n    while (low !== high) {\n      mid = (low + high + 1) >> 1\n      current = list[mid].factor\n\n      if (current > value) {\n        high = mid - 1\n      } else {\n        low = mid\n      }\n    }\n\n    return list[low]\n  }\n\n  Scale.prototype.parse = function Scale$parse (str, strict) {\n    var matches = str.match(this._regexp)\n\n    if (matches === null) {\n      return\n    }\n\n    var prefix = matches[3]\n    var factor\n\n    if (has(this._prefixes, prefix)) {\n      factor = this._prefixes[prefix]\n    } else if (\n      !strict &&\n      (prefix = prefix.toLowerCase(), has(this._lcPrefixes, prefix))\n    ) {\n      prefix = this._lcPrefixes[prefix]\n      factor = this._prefixes[prefix]\n    } else {\n      return\n    }\n\n    var value = +matches[2]\n    if (matches[1] !== undefined) {\n      value = -value\n    }\n\n    return {\n      factor: factor,\n      prefix: prefix,\n      unit: matches[4],\n      value: value\n    }\n  }\n\n  // =================================================================\n\n  var scales = {\n    // https://en.wikipedia.org/wiki/Binary_prefix\n    binary: Scale.create(\n      ',Ki,Mi,Gi,Ti,Pi,Ei,Zi,Yi'.split(','),\n      1024\n    ),\n\n    // https://en.wikipedia.org/wiki/Metric_prefix\n    //\n    // Not all prefixes are present, only those which are multiple of\n    // 1000, because humans usually prefer to see close numbers using\n    // the same unit to ease the comparison.\n    SI: Scale.create(\n      'y,z,a,f,p,n,µ,m,,k,M,G,T,P,E,Z,Y'.split(','),\n      1000, -8\n    )\n  }\n\n  var defaults = {\n    // Decimal digits for formatting.\n    decimals: 2,\n\n    // separator to use between value and units\n    separator: ' ',\n\n    // Unit to use for formatting.\n    unit: ''\n  }\n  var rawDefaults = {\n    scale: 'SI',\n\n    // Strict mode prevents parsing of incorrectly cased prefixes.\n    strict: false\n  }\n\n  function humanFormat (value, opts) {\n    opts = assign({}, defaults, opts)\n\n    var info = humanFormat$raw(value, opts)\n    value = String(info.value)\n    var suffix = info.prefix + opts.unit\n    return suffix === '' ? value : value + opts.separator + suffix\n  }\n\n  var humanFormat$bytes$opts = { scale: 'binary', unit: 'B' }\n  function humanFormat$bytes (value, opts) {\n    return humanFormat(\n      value,\n      opts === undefined\n        ? humanFormat$bytes$opts\n        : assign({}, humanFormat$bytes$opts, opts)\n    )\n  }\n\n  function humanFormat$parse (str, opts) {\n    var info = humanFormat$parse$raw(str, opts)\n\n    return info.value * info.factor\n  }\n\n  function humanFormat$parse$raw (str, opts) {\n    if (typeof str !== 'string') {\n      throw new TypeError('str must be a string')\n    }\n\n    // Merge default options.\n    opts = assign({}, rawDefaults, opts)\n\n    // Get current scale.\n    var scale = resolve(scales, opts.scale)\n    if (scale === undefined) {\n      throw new Error('missing scale')\n    }\n\n    // TODO: the unit should be checked: it might be absent but it\n    // should not differ from the one expected.\n    //\n    // TODO: if multiple units are specified, at least must match and\n    // the returned value should be: { value: <value>, unit: matchedUnit }\n\n    var info = scale.parse(str, opts.strict)\n    if (info === undefined) {\n      throw new Error('cannot parse str')\n    }\n\n    return info\n  }\n\n  function humanFormat$raw (value, opts) {\n    // Zero is a special case, it never has any prefix.\n    if (value === 0) {\n      return {\n        value: 0,\n        prefix: ''\n      }\n    } else if (value < 0) {\n      var result = humanFormat$raw(-value, opts)\n      result.value = -result.value\n      return result\n    }\n\n    if (typeof value !== 'number' || Number.isNaN(value)) {\n      throw new TypeError('value must be a number')\n    }\n\n    // Merge default options.\n    opts = assign({}, rawDefaults, opts)\n\n    // Get current scale.\n    var scale = resolve(scales, opts.scale)\n    if (scale === undefined) {\n      throw new Error('missing scale')\n    }\n\n    var power\n    var decimals = opts.decimals\n    if (decimals !== undefined) {\n      power = Math.pow(10, decimals)\n    }\n\n    var prefix = opts.prefix\n    var factor\n    if (prefix !== undefined) {\n      if (!has(scale._prefixes, prefix)) {\n        throw new Error('invalid prefix')\n      }\n\n      factor = scale._prefixes[prefix]\n    } else {\n      var _ref = scale.findPrefix(value)\n      if (power !== undefined) {\n        do {\n          factor = _ref.factor\n\n          // factor is usually >> power, therefore it's better to\n          // divide factor by power than the other way to limit\n          // numerical error\n          var r = factor / power\n\n          value = Math.round(value / r) * r\n        } while ((_ref = scale.findPrefix(value)).factor !== factor)\n      } else {\n        factor = _ref.factor\n      }\n\n      prefix = _ref.prefix\n    }\n\n    return {\n      prefix: prefix,\n      value: power === undefined\n        ? value / factor\n        : Math.round(value * power / factor) / power\n    }\n  }\n\n  humanFormat.bytes = humanFormat$bytes\n  humanFormat.parse = humanFormat$parse\n  humanFormat$parse.raw = humanFormat$parse$raw\n  humanFormat.raw = humanFormat$raw\n  humanFormat.Scale = Scale\n\n  return humanFormat\n}))\n"]},"metadata":{},"sourceType":"script"}